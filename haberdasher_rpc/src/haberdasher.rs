// This file is generated by rust-protobuf 2.1.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct Empty {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Empty {
    pub fn new() -> Empty {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Empty {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Empty {
        Empty::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Empty>(
                    "Empty",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Empty {
        static mut instance: ::protobuf::lazy::Lazy<Empty> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Empty,
        };
        unsafe {
            instance.get(Empty::new)
        }
    }
}

impl ::protobuf::Clear for Empty {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Empty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Empty {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EstablishClientRequest {
    // message fields
    pub name: ::std::string::String,
    pub protocol: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl EstablishClientRequest {
    pub fn new() -> EstablishClientRequest {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }

    // string protocol = 2;

    pub fn clear_protocol(&mut self) {
        self.protocol.clear();
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: ::std::string::String) {
        self.protocol = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol(&mut self) -> &mut ::std::string::String {
        &mut self.protocol
    }

    // Take field
    pub fn take_protocol(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.protocol, ::std::string::String::new())
    }

    pub fn get_protocol(&self) -> &str {
        &self.protocol
    }
}

impl ::protobuf::Message for EstablishClientRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.protocol)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.protocol.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.protocol);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.protocol.is_empty() {
            os.write_string(2, &self.protocol)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EstablishClientRequest {
        EstablishClientRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &EstablishClientRequest| { &m.name },
                    |m: &mut EstablishClientRequest| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "protocol",
                    |m: &EstablishClientRequest| { &m.protocol },
                    |m: &mut EstablishClientRequest| { &mut m.protocol },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EstablishClientRequest>(
                    "EstablishClientRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EstablishClientRequest {
        static mut instance: ::protobuf::lazy::Lazy<EstablishClientRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EstablishClientRequest,
        };
        unsafe {
            instance.get(EstablishClientRequest::new)
        }
    }
}

impl ::protobuf::Clear for EstablishClientRequest {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_protocol();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EstablishClientRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EstablishClientRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AgentRequest {
    // message fields
    pub seqno: i64,
    // message oneof groups
    pub kind: ::std::option::Option<AgentRequest_oneof_kind>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum AgentRequest_oneof_kind {
    list_venues(ListVenuesRequest),
}

impl AgentRequest {
    pub fn new() -> AgentRequest {
        ::std::default::Default::default()
    }

    // int64 seqno = 1;

    pub fn clear_seqno(&mut self) {
        self.seqno = 0;
    }

    // Param is passed by value, moved
    pub fn set_seqno(&mut self, v: i64) {
        self.seqno = v;
    }

    pub fn get_seqno(&self) -> i64 {
        self.seqno
    }

    // .haberdasher.ListVenuesRequest list_venues = 2;

    pub fn clear_list_venues(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_list_venues(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(AgentRequest_oneof_kind::list_venues(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_list_venues(&mut self, v: ListVenuesRequest) {
        self.kind = ::std::option::Option::Some(AgentRequest_oneof_kind::list_venues(v))
    }

    // Mutable pointer to the field.
    pub fn mut_list_venues(&mut self) -> &mut ListVenuesRequest {
        if let ::std::option::Option::Some(AgentRequest_oneof_kind::list_venues(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(AgentRequest_oneof_kind::list_venues(ListVenuesRequest::new()));
        }
        match self.kind {
            ::std::option::Option::Some(AgentRequest_oneof_kind::list_venues(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_list_venues(&mut self) -> ListVenuesRequest {
        if self.has_list_venues() {
            match self.kind.take() {
                ::std::option::Option::Some(AgentRequest_oneof_kind::list_venues(v)) => v,
                _ => panic!(),
            }
        } else {
            ListVenuesRequest::new()
        }
    }

    pub fn get_list_venues(&self) -> &ListVenuesRequest {
        match self.kind {
            ::std::option::Option::Some(AgentRequest_oneof_kind::list_venues(ref v)) => v,
            _ => ListVenuesRequest::default_instance(),
        }
    }
}

impl ::protobuf::Message for AgentRequest {
    fn is_initialized(&self) -> bool {
        if let Some(AgentRequest_oneof_kind::list_venues(ref v)) = self.kind {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.seqno = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(AgentRequest_oneof_kind::list_venues(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.seqno != 0 {
            my_size += ::protobuf::rt::value_size(1, self.seqno, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.kind {
            match v {
                &AgentRequest_oneof_kind::list_venues(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.seqno != 0 {
            os.write_int64(1, self.seqno)?;
        }
        if let ::std::option::Option::Some(ref v) = self.kind {
            match v {
                &AgentRequest_oneof_kind::list_venues(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AgentRequest {
        AgentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "seqno",
                    |m: &AgentRequest| { &m.seqno },
                    |m: &mut AgentRequest| { &mut m.seqno },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ListVenuesRequest>(
                    "list_venues",
                    AgentRequest::has_list_venues,
                    AgentRequest::get_list_venues,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AgentRequest>(
                    "AgentRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AgentRequest {
        static mut instance: ::protobuf::lazy::Lazy<AgentRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AgentRequest,
        };
        unsafe {
            instance.get(AgentRequest::new)
        }
    }
}

impl ::protobuf::Clear for AgentRequest {
    fn clear(&mut self) {
        self.clear_seqno();
        self.clear_list_venues();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AgentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AgentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AgentResponse {
    // message fields
    pub seqno: i64,
    // message oneof groups
    pub kind: ::std::option::Option<AgentResponse_oneof_kind>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum AgentResponse_oneof_kind {
    error(AgentErrorResponse),
    list_venues(ListVenuesResponse),
}

impl AgentResponse {
    pub fn new() -> AgentResponse {
        ::std::default::Default::default()
    }

    // int64 seqno = 1;

    pub fn clear_seqno(&mut self) {
        self.seqno = 0;
    }

    // Param is passed by value, moved
    pub fn set_seqno(&mut self, v: i64) {
        self.seqno = v;
    }

    pub fn get_seqno(&self) -> i64 {
        self.seqno
    }

    // .haberdasher.AgentErrorResponse error = 2;

    pub fn clear_error(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(AgentResponse_oneof_kind::error(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: AgentErrorResponse) {
        self.kind = ::std::option::Option::Some(AgentResponse_oneof_kind::error(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error(&mut self) -> &mut AgentErrorResponse {
        if let ::std::option::Option::Some(AgentResponse_oneof_kind::error(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(AgentResponse_oneof_kind::error(AgentErrorResponse::new()));
        }
        match self.kind {
            ::std::option::Option::Some(AgentResponse_oneof_kind::error(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error(&mut self) -> AgentErrorResponse {
        if self.has_error() {
            match self.kind.take() {
                ::std::option::Option::Some(AgentResponse_oneof_kind::error(v)) => v,
                _ => panic!(),
            }
        } else {
            AgentErrorResponse::new()
        }
    }

    pub fn get_error(&self) -> &AgentErrorResponse {
        match self.kind {
            ::std::option::Option::Some(AgentResponse_oneof_kind::error(ref v)) => v,
            _ => AgentErrorResponse::default_instance(),
        }
    }

    // .haberdasher.ListVenuesResponse list_venues = 3;

    pub fn clear_list_venues(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_list_venues(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(AgentResponse_oneof_kind::list_venues(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_list_venues(&mut self, v: ListVenuesResponse) {
        self.kind = ::std::option::Option::Some(AgentResponse_oneof_kind::list_venues(v))
    }

    // Mutable pointer to the field.
    pub fn mut_list_venues(&mut self) -> &mut ListVenuesResponse {
        if let ::std::option::Option::Some(AgentResponse_oneof_kind::list_venues(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(AgentResponse_oneof_kind::list_venues(ListVenuesResponse::new()));
        }
        match self.kind {
            ::std::option::Option::Some(AgentResponse_oneof_kind::list_venues(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_list_venues(&mut self) -> ListVenuesResponse {
        if self.has_list_venues() {
            match self.kind.take() {
                ::std::option::Option::Some(AgentResponse_oneof_kind::list_venues(v)) => v,
                _ => panic!(),
            }
        } else {
            ListVenuesResponse::new()
        }
    }

    pub fn get_list_venues(&self) -> &ListVenuesResponse {
        match self.kind {
            ::std::option::Option::Some(AgentResponse_oneof_kind::list_venues(ref v)) => v,
            _ => ListVenuesResponse::default_instance(),
        }
    }
}

impl ::protobuf::Message for AgentResponse {
    fn is_initialized(&self) -> bool {
        if let Some(AgentResponse_oneof_kind::error(ref v)) = self.kind {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(AgentResponse_oneof_kind::list_venues(ref v)) = self.kind {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.seqno = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(AgentResponse_oneof_kind::error(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(AgentResponse_oneof_kind::list_venues(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.seqno != 0 {
            my_size += ::protobuf::rt::value_size(1, self.seqno, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.kind {
            match v {
                &AgentResponse_oneof_kind::error(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &AgentResponse_oneof_kind::list_venues(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.seqno != 0 {
            os.write_int64(1, self.seqno)?;
        }
        if let ::std::option::Option::Some(ref v) = self.kind {
            match v {
                &AgentResponse_oneof_kind::error(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &AgentResponse_oneof_kind::list_venues(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AgentResponse {
        AgentResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "seqno",
                    |m: &AgentResponse| { &m.seqno },
                    |m: &mut AgentResponse| { &mut m.seqno },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AgentErrorResponse>(
                    "error",
                    AgentResponse::has_error,
                    AgentResponse::get_error,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ListVenuesResponse>(
                    "list_venues",
                    AgentResponse::has_list_venues,
                    AgentResponse::get_list_venues,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AgentResponse>(
                    "AgentResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AgentResponse {
        static mut instance: ::protobuf::lazy::Lazy<AgentResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AgentResponse,
        };
        unsafe {
            instance.get(AgentResponse::new)
        }
    }
}

impl ::protobuf::Clear for AgentResponse {
    fn clear(&mut self) {
        self.clear_seqno();
        self.clear_error();
        self.clear_list_venues();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AgentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AgentResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AgentErrorResponse {
    // message fields
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl AgentErrorResponse {
    pub fn new() -> AgentErrorResponse {
        ::std::default::Default::default()
    }

    // string message = 1;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        &self.message
    }
}

impl ::protobuf::Message for AgentErrorResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AgentErrorResponse {
        AgentErrorResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &AgentErrorResponse| { &m.message },
                    |m: &mut AgentErrorResponse| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AgentErrorResponse>(
                    "AgentErrorResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AgentErrorResponse {
        static mut instance: ::protobuf::lazy::Lazy<AgentErrorResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AgentErrorResponse,
        };
        unsafe {
            instance.get(AgentErrorResponse::new)
        }
    }
}

impl ::protobuf::Clear for AgentErrorResponse {
    fn clear(&mut self) {
        self.clear_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AgentErrorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AgentErrorResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListVenuesRequest {
    // message fields
    pub with_updates_since: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ListVenuesRequest {
    pub fn new() -> ListVenuesRequest {
        ::std::default::Default::default()
    }

    // .google.protobuf.Timestamp with_updates_since = 1;

    pub fn clear_with_updates_since(&mut self) {
        self.with_updates_since.clear();
    }

    pub fn has_with_updates_since(&self) -> bool {
        self.with_updates_since.is_some()
    }

    // Param is passed by value, moved
    pub fn set_with_updates_since(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.with_updates_since = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_with_updates_since(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.with_updates_since.is_none() {
            self.with_updates_since.set_default();
        }
        self.with_updates_since.as_mut().unwrap()
    }

    // Take field
    pub fn take_with_updates_since(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.with_updates_since.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_with_updates_since(&self) -> &::protobuf::well_known_types::Timestamp {
        self.with_updates_since.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
}

impl ::protobuf::Message for ListVenuesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.with_updates_since {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.with_updates_since)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.with_updates_since.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.with_updates_since.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListVenuesRequest {
        ListVenuesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "with_updates_since",
                    |m: &ListVenuesRequest| { &m.with_updates_since },
                    |m: &mut ListVenuesRequest| { &mut m.with_updates_since },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListVenuesRequest>(
                    "ListVenuesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListVenuesRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListVenuesRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListVenuesRequest,
        };
        unsafe {
            instance.get(ListVenuesRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListVenuesRequest {
    fn clear(&mut self) {
        self.clear_with_updates_since();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListVenuesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListVenuesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListVenuesResponse {
    // message fields
    pub venues: ::protobuf::RepeatedField<Venue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ListVenuesResponse {
    pub fn new() -> ListVenuesResponse {
        ::std::default::Default::default()
    }

    // repeated .haberdasher.Venue venues = 1;

    pub fn clear_venues(&mut self) {
        self.venues.clear();
    }

    // Param is passed by value, moved
    pub fn set_venues(&mut self, v: ::protobuf::RepeatedField<Venue>) {
        self.venues = v;
    }

    // Mutable pointer to the field.
    pub fn mut_venues(&mut self) -> &mut ::protobuf::RepeatedField<Venue> {
        &mut self.venues
    }

    // Take field
    pub fn take_venues(&mut self) -> ::protobuf::RepeatedField<Venue> {
        ::std::mem::replace(&mut self.venues, ::protobuf::RepeatedField::new())
    }

    pub fn get_venues(&self) -> &[Venue] {
        &self.venues
    }
}

impl ::protobuf::Message for ListVenuesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.venues {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.venues)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.venues {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.venues {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListVenuesResponse {
        ListVenuesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Venue>>(
                    "venues",
                    |m: &ListVenuesResponse| { &m.venues },
                    |m: &mut ListVenuesResponse| { &mut m.venues },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListVenuesResponse>(
                    "ListVenuesResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListVenuesResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListVenuesResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListVenuesResponse,
        };
        unsafe {
            instance.get(ListVenuesResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListVenuesResponse {
    fn clear(&mut self) {
        self.clear_venues();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListVenuesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListVenuesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Instance {
    // message fields
    pub id: ::std::vec::Vec<u8>,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Instance {
    pub fn new() -> Instance {
        ::std::default::Default::default()
    }

    // bytes id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.id, ::std::vec::Vec::new())
    }

    pub fn get_id(&self) -> &[u8] {
        &self.id
    }

    // string name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }
}

impl ::protobuf::Message for Instance {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_bytes(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Instance {
        Instance::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "id",
                    |m: &Instance| { &m.id },
                    |m: &mut Instance| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Instance| { &m.name },
                    |m: &mut Instance| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Instance>(
                    "Instance",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Instance {
        static mut instance: ::protobuf::lazy::Lazy<Instance> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Instance,
        };
        unsafe {
            instance.get(Instance::new)
        }
    }
}

impl ::protobuf::Clear for Instance {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Instance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Instance {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Individual {
    // message fields
    pub id: ::std::vec::Vec<u8>,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Individual {
    pub fn new() -> Individual {
        ::std::default::Default::default()
    }

    // bytes id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.id, ::std::vec::Vec::new())
    }

    pub fn get_id(&self) -> &[u8] {
        &self.id
    }

    // string name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }
}

impl ::protobuf::Message for Individual {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_bytes(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Individual {
        Individual::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "id",
                    |m: &Individual| { &m.id },
                    |m: &mut Individual| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Individual| { &m.name },
                    |m: &mut Individual| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Individual>(
                    "Individual",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Individual {
        static mut instance: ::protobuf::lazy::Lazy<Individual> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Individual,
        };
        unsafe {
            instance.get(Individual::new)
        }
    }
}

impl ::protobuf::Clear for Individual {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Individual {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Individual {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Group {
    // message fields
    pub id: ::std::vec::Vec<u8>,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Group {
    pub fn new() -> Group {
        ::std::default::Default::default()
    }

    // bytes id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.id, ::std::vec::Vec::new())
    }

    pub fn get_id(&self) -> &[u8] {
        &self.id
    }

    // string name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }
}

impl ::protobuf::Message for Group {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_bytes(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Group {
        Group::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "id",
                    |m: &Group| { &m.id },
                    |m: &mut Group| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Group| { &m.name },
                    |m: &mut Group| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Group>(
                    "Group",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Group {
        static mut instance: ::protobuf::lazy::Lazy<Group> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Group,
        };
        unsafe {
            instance.get(Group::new)
        }
    }
}

impl ::protobuf::Clear for Group {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Group {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Group {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Performer {
    // message oneof groups
    pub kind: ::std::option::Option<Performer_oneof_kind>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum Performer_oneof_kind {
    individual(Individual),
    service(bool),
    myself(bool),
}

impl Performer {
    pub fn new() -> Performer {
        ::std::default::Default::default()
    }

    // .haberdasher.Individual individual = 1;

    pub fn clear_individual(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_individual(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(Performer_oneof_kind::individual(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_individual(&mut self, v: Individual) {
        self.kind = ::std::option::Option::Some(Performer_oneof_kind::individual(v))
    }

    // Mutable pointer to the field.
    pub fn mut_individual(&mut self) -> &mut Individual {
        if let ::std::option::Option::Some(Performer_oneof_kind::individual(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(Performer_oneof_kind::individual(Individual::new()));
        }
        match self.kind {
            ::std::option::Option::Some(Performer_oneof_kind::individual(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_individual(&mut self) -> Individual {
        if self.has_individual() {
            match self.kind.take() {
                ::std::option::Option::Some(Performer_oneof_kind::individual(v)) => v,
                _ => panic!(),
            }
        } else {
            Individual::new()
        }
    }

    pub fn get_individual(&self) -> &Individual {
        match self.kind {
            ::std::option::Option::Some(Performer_oneof_kind::individual(ref v)) => v,
            _ => Individual::default_instance(),
        }
    }

    // bool service = 2;

    pub fn clear_service(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_service(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(Performer_oneof_kind::service(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: bool) {
        self.kind = ::std::option::Option::Some(Performer_oneof_kind::service(v))
    }

    pub fn get_service(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(Performer_oneof_kind::service(v)) => v,
            _ => false,
        }
    }

    // bool myself = 3;

    pub fn clear_myself(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_myself(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(Performer_oneof_kind::myself(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_myself(&mut self, v: bool) {
        self.kind = ::std::option::Option::Some(Performer_oneof_kind::myself(v))
    }

    pub fn get_myself(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(Performer_oneof_kind::myself(v)) => v,
            _ => false,
        }
    }
}

impl ::protobuf::Message for Performer {
    fn is_initialized(&self) -> bool {
        if let Some(Performer_oneof_kind::individual(ref v)) = self.kind {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(Performer_oneof_kind::individual(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(Performer_oneof_kind::service(is.read_bool()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(Performer_oneof_kind::myself(is.read_bool()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.kind {
            match v {
                &Performer_oneof_kind::individual(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Performer_oneof_kind::service(v) => {
                    my_size += 2;
                },
                &Performer_oneof_kind::myself(v) => {
                    my_size += 2;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.kind {
            match v {
                &Performer_oneof_kind::individual(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Performer_oneof_kind::service(v) => {
                    os.write_bool(2, v)?;
                },
                &Performer_oneof_kind::myself(v) => {
                    os.write_bool(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Performer {
        Performer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Individual>(
                    "individual",
                    Performer::has_individual,
                    Performer::get_individual,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                    "service",
                    Performer::has_service,
                    Performer::get_service,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                    "myself",
                    Performer::has_myself,
                    Performer::get_myself,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Performer>(
                    "Performer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Performer {
        static mut instance: ::protobuf::lazy::Lazy<Performer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Performer,
        };
        unsafe {
            instance.get(Performer::new)
        }
    }
}

impl ::protobuf::Clear for Performer {
    fn clear(&mut self) {
        self.clear_individual();
        self.clear_service();
        self.clear_myself();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Performer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Performer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Message {
    // message fields
    pub performer: ::protobuf::SingularPtrField<Performer>,
    pub at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // message oneof groups
    pub content: ::std::option::Option<Message_oneof_content>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum Message_oneof_content {
    text(::std::string::String),
    pose(::std::string::String),
}

impl Message {
    pub fn new() -> Message {
        ::std::default::Default::default()
    }

    // .haberdasher.Performer performer = 1;

    pub fn clear_performer(&mut self) {
        self.performer.clear();
    }

    pub fn has_performer(&self) -> bool {
        self.performer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_performer(&mut self, v: Performer) {
        self.performer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_performer(&mut self) -> &mut Performer {
        if self.performer.is_none() {
            self.performer.set_default();
        }
        self.performer.as_mut().unwrap()
    }

    // Take field
    pub fn take_performer(&mut self) -> Performer {
        self.performer.take().unwrap_or_else(|| Performer::new())
    }

    pub fn get_performer(&self) -> &Performer {
        self.performer.as_ref().unwrap_or_else(|| Performer::default_instance())
    }

    // .google.protobuf.Timestamp at = 2;

    pub fn clear_at(&mut self) {
        self.at.clear();
    }

    pub fn has_at(&self) -> bool {
        self.at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.at.is_none() {
            self.at.set_default();
        }
        self.at.as_mut().unwrap()
    }

    // Take field
    pub fn take_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.at.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }

    // string text = 3;

    pub fn clear_text(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::text(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.content = ::std::option::Option::Some(Message_oneof_content::text(v))
    }

    // Mutable pointer to the field.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Message_oneof_content::text(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(Message_oneof_content::text(::std::string::String::new()));
        }
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::text(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        if self.has_text() {
            match self.content.take() {
                ::std::option::Option::Some(Message_oneof_content::text(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    pub fn get_text(&self) -> &str {
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::text(ref v)) => v,
            _ => "",
        }
    }

    // string pose = 4;

    pub fn clear_pose(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_pose(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::pose(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pose(&mut self, v: ::std::string::String) {
        self.content = ::std::option::Option::Some(Message_oneof_content::pose(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pose(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Message_oneof_content::pose(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(Message_oneof_content::pose(::std::string::String::new()));
        }
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::pose(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pose(&mut self) -> ::std::string::String {
        if self.has_pose() {
            match self.content.take() {
                ::std::option::Option::Some(Message_oneof_content::pose(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    pub fn get_pose(&self) -> &str {
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::pose(ref v)) => v,
            _ => "",
        }
    }
}

impl ::protobuf::Message for Message {
    fn is_initialized(&self) -> bool {
        for v in &self.performer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.at {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.performer)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.at)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(Message_oneof_content::text(is.read_string()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(Message_oneof_content::pose(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.performer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.content {
            match v {
                &Message_oneof_content::text(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
                &Message_oneof_content::pose(ref v) => {
                    my_size += ::protobuf::rt::string_size(4, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.performer.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.at.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.content {
            match v {
                &Message_oneof_content::text(ref v) => {
                    os.write_string(3, v)?;
                },
                &Message_oneof_content::pose(ref v) => {
                    os.write_string(4, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Message {
        Message::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Performer>>(
                    "performer",
                    |m: &Message| { &m.performer },
                    |m: &mut Message| { &mut m.performer },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "at",
                    |m: &Message| { &m.at },
                    |m: &mut Message| { &mut m.at },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "text",
                    Message::has_text,
                    Message::get_text,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "pose",
                    Message::has_pose,
                    Message::get_pose,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Message>(
                    "Message",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Message {
        static mut instance: ::protobuf::lazy::Lazy<Message> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Message,
        };
        unsafe {
            instance.get(Message::new)
        }
    }
}

impl ::protobuf::Clear for Message {
    fn clear(&mut self) {
        self.clear_performer();
        self.clear_at();
        self.clear_text();
        self.clear_pose();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Message {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Message {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Venue {
    // message fields
    pub instance: ::protobuf::SingularPtrField<Instance>,
    pub last_message: ::protobuf::SingularPtrField<Message>,
    // message oneof groups
    pub kind: ::std::option::Option<Venue_oneof_kind>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum Venue_oneof_kind {
    individual(Individual),
    group(Group),
    service(bool),
}

impl Venue {
    pub fn new() -> Venue {
        ::std::default::Default::default()
    }

    // .haberdasher.Individual individual = 1;

    pub fn clear_individual(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_individual(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(Venue_oneof_kind::individual(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_individual(&mut self, v: Individual) {
        self.kind = ::std::option::Option::Some(Venue_oneof_kind::individual(v))
    }

    // Mutable pointer to the field.
    pub fn mut_individual(&mut self) -> &mut Individual {
        if let ::std::option::Option::Some(Venue_oneof_kind::individual(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(Venue_oneof_kind::individual(Individual::new()));
        }
        match self.kind {
            ::std::option::Option::Some(Venue_oneof_kind::individual(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_individual(&mut self) -> Individual {
        if self.has_individual() {
            match self.kind.take() {
                ::std::option::Option::Some(Venue_oneof_kind::individual(v)) => v,
                _ => panic!(),
            }
        } else {
            Individual::new()
        }
    }

    pub fn get_individual(&self) -> &Individual {
        match self.kind {
            ::std::option::Option::Some(Venue_oneof_kind::individual(ref v)) => v,
            _ => Individual::default_instance(),
        }
    }

    // .haberdasher.Group group = 2;

    pub fn clear_group(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_group(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(Venue_oneof_kind::group(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: Group) {
        self.kind = ::std::option::Option::Some(Venue_oneof_kind::group(v))
    }

    // Mutable pointer to the field.
    pub fn mut_group(&mut self) -> &mut Group {
        if let ::std::option::Option::Some(Venue_oneof_kind::group(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(Venue_oneof_kind::group(Group::new()));
        }
        match self.kind {
            ::std::option::Option::Some(Venue_oneof_kind::group(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_group(&mut self) -> Group {
        if self.has_group() {
            match self.kind.take() {
                ::std::option::Option::Some(Venue_oneof_kind::group(v)) => v,
                _ => panic!(),
            }
        } else {
            Group::new()
        }
    }

    pub fn get_group(&self) -> &Group {
        match self.kind {
            ::std::option::Option::Some(Venue_oneof_kind::group(ref v)) => v,
            _ => Group::default_instance(),
        }
    }

    // bool service = 3;

    pub fn clear_service(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_service(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(Venue_oneof_kind::service(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: bool) {
        self.kind = ::std::option::Option::Some(Venue_oneof_kind::service(v))
    }

    pub fn get_service(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(Venue_oneof_kind::service(v)) => v,
            _ => false,
        }
    }

    // .haberdasher.Instance instance = 4;

    pub fn clear_instance(&mut self) {
        self.instance.clear();
    }

    pub fn has_instance(&self) -> bool {
        self.instance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance(&mut self, v: Instance) {
        self.instance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instance(&mut self) -> &mut Instance {
        if self.instance.is_none() {
            self.instance.set_default();
        }
        self.instance.as_mut().unwrap()
    }

    // Take field
    pub fn take_instance(&mut self) -> Instance {
        self.instance.take().unwrap_or_else(|| Instance::new())
    }

    pub fn get_instance(&self) -> &Instance {
        self.instance.as_ref().unwrap_or_else(|| Instance::default_instance())
    }

    // .haberdasher.Message last_message = 5;

    pub fn clear_last_message(&mut self) {
        self.last_message.clear();
    }

    pub fn has_last_message(&self) -> bool {
        self.last_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_message(&mut self, v: Message) {
        self.last_message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_message(&mut self) -> &mut Message {
        if self.last_message.is_none() {
            self.last_message.set_default();
        }
        self.last_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_message(&mut self) -> Message {
        self.last_message.take().unwrap_or_else(|| Message::new())
    }

    pub fn get_last_message(&self) -> &Message {
        self.last_message.as_ref().unwrap_or_else(|| Message::default_instance())
    }
}

impl ::protobuf::Message for Venue {
    fn is_initialized(&self) -> bool {
        if let Some(Venue_oneof_kind::individual(ref v)) = self.kind {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Venue_oneof_kind::group(ref v)) = self.kind {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.instance {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.last_message {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(Venue_oneof_kind::individual(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(Venue_oneof_kind::group(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(Venue_oneof_kind::service(is.read_bool()?));
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instance)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.last_message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.instance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.last_message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.kind {
            match v {
                &Venue_oneof_kind::individual(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Venue_oneof_kind::group(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Venue_oneof_kind::service(v) => {
                    my_size += 2;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.instance.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.last_message.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.kind {
            match v {
                &Venue_oneof_kind::individual(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Venue_oneof_kind::group(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Venue_oneof_kind::service(v) => {
                    os.write_bool(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Venue {
        Venue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Individual>(
                    "individual",
                    Venue::has_individual,
                    Venue::get_individual,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Group>(
                    "group",
                    Venue::has_group,
                    Venue::get_group,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                    "service",
                    Venue::has_service,
                    Venue::get_service,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instance>>(
                    "instance",
                    |m: &Venue| { &m.instance },
                    |m: &mut Venue| { &mut m.instance },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Message>>(
                    "last_message",
                    |m: &Venue| { &m.last_message },
                    |m: &mut Venue| { &mut m.last_message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Venue>(
                    "Venue",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Venue {
        static mut instance: ::protobuf::lazy::Lazy<Venue> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Venue,
        };
        unsafe {
            instance.get(Venue::new)
        }
    }
}

impl ::protobuf::Clear for Venue {
    fn clear(&mut self) {
        self.clear_individual();
        self.clear_group();
        self.clear_service();
        self.clear_instance();
        self.clear_last_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Venue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Venue {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x11haberdasher.proto\x12\x0bhaberdasher\x1a\x1fgoogle/protobuf/timest\
    amp.proto\"\x07\n\x05Empty\"H\n\x16EstablishClientRequest\x12\x12\n\x04n\
    ame\x18\x01\x20\x01(\tR\x04name\x12\x1a\n\x08protocol\x18\x02\x20\x01(\t\
    R\x08protocol\"o\n\x0cAgentRequest\x12\x14\n\x05seqno\x18\x01\x20\x01(\
    \x03R\x05seqno\x12A\n\x0blist_venues\x18\x02\x20\x01(\x0b2\x1e.haberdash\
    er.ListVenuesRequestH\0R\nlistVenuesB\x06\n\x04kind\"\xaa\x01\n\rAgentRe\
    sponse\x12\x14\n\x05seqno\x18\x01\x20\x01(\x03R\x05seqno\x127\n\x05error\
    \x18\x02\x20\x01(\x0b2\x1f.haberdasher.AgentErrorResponseH\0R\x05error\
    \x12B\n\x0blist_venues\x18\x03\x20\x01(\x0b2\x1f.haberdasher.ListVenuesR\
    esponseH\0R\nlistVenuesB\x06\n\x04kind\".\n\x12AgentErrorResponse\x12\
    \x18\n\x07message\x18\x01\x20\x01(\tR\x07message\"]\n\x11ListVenuesReque\
    st\x12H\n\x12with_updates_since\x18\x01\x20\x01(\x0b2\x1a.google.protobu\
    f.TimestampR\x10withUpdatesSince\"@\n\x12ListVenuesResponse\x12*\n\x06ve\
    nues\x18\x01\x20\x03(\x0b2\x12.haberdasher.VenueR\x06venues\".\n\x08Inst\
    ance\x12\x0e\n\x02id\x18\x01\x20\x01(\x0cR\x02id\x12\x12\n\x04name\x18\
    \x02\x20\x01(\tR\x04name\"0\n\nIndividual\x12\x0e\n\x02id\x18\x01\x20\
    \x01(\x0cR\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\"+\n\x05G\
    roup\x12\x0e\n\x02id\x18\x01\x20\x01(\x0cR\x02id\x12\x12\n\x04name\x18\
    \x02\x20\x01(\tR\x04name\"\x84\x01\n\tPerformer\x129\n\nindividual\x18\
    \x01\x20\x01(\x0b2\x17.haberdasher.IndividualH\0R\nindividual\x12\x1a\n\
    \x07service\x18\x02\x20\x01(\x08H\0R\x07service\x12\x18\n\x06myself\x18\
    \x03\x20\x01(\x08H\0R\x06myselfB\x06\n\x04kind\"\xa2\x01\n\x07Message\
    \x124\n\tperformer\x18\x01\x20\x01(\x0b2\x16.haberdasher.PerformerR\tper\
    former\x12*\n\x02at\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\
    \x02at\x12\x14\n\x04text\x18\x03\x20\x01(\tH\0R\x04text\x12\x14\n\x04pos\
    e\x18\x04\x20\x01(\tH\0R\x04poseB\t\n\x07content\"\xfe\x01\n\x05Venue\
    \x129\n\nindividual\x18\x01\x20\x01(\x0b2\x17.haberdasher.IndividualH\0R\
    \nindividual\x12*\n\x05group\x18\x02\x20\x01(\x0b2\x12.haberdasher.Group\
    H\0R\x05group\x12\x1a\n\x07service\x18\x03\x20\x01(\x08H\0R\x07service\
    \x121\n\x08instance\x18\x04\x20\x01(\x0b2\x15.haberdasher.InstanceR\x08i\
    nstance\x127\n\x0clast_message\x18\x05\x20\x01(\x0b2\x14.haberdasher.Mes\
    sageR\x0blastMessageB\x06\n\x04kind2\xf0\x01\n\x0fAgentSubscriber\x12J\n\
    \x0fEstablishClient\x12#.haberdasher.EstablishClientRequest\x1a\x12.habe\
    rdasher.Empty\x12P\n\x13HandleAgentRequests\x12\x1a.haberdasher.AgentRes\
    ponse\x1a\x19.haberdasher.AgentRequest(\x010\x01\x12?\n\x13PublishVenueU\
    pdates\x12\x12.haberdasher.Venue\x1a\x12.haberdasher.Empty(\x01J\xd3\x13\
    \n\x06\x12\x04\0\0U\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\
    \x12\x03\x01\x08\x13\n\t\n\x02\x03\0\x12\x03\x03\x07(\n\t\n\x02\x04\0\
    \x12\x03\x05\0\x10\n\n\n\x03\x04\0\x01\x12\x03\x05\x08\r\n\n\n\x02\x06\0\
    \x12\x04\x07\0\x0b\x01\n\n\n\x03\x06\0\x01\x12\x03\x07\x08\x17\n\x0b\n\
    \x04\x06\0\x02\0\x12\x03\x08\x04A\n\x0c\n\x05\x06\0\x02\0\x01\x12\x03\
    \x08\x08\x17\n\x0c\n\x05\x06\0\x02\0\x02\x12\x03\x08\x19/\n\x0c\n\x05\
    \x06\0\x02\0\x03\x12\x03\x08:?\n\x0b\n\x04\x06\0\x02\x01\x12\x03\t\x04Q\
    \n\x0c\n\x05\x06\0\x02\x01\x01\x12\x03\t\x08\x1b\n\x0c\n\x05\x06\0\x02\
    \x01\x05\x12\x03\t\x1d#\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03\t$1\n\x0c\
    \n\x05\x06\0\x02\x01\x06\x12\x03\t<B\n\x0c\n\x05\x06\0\x02\x01\x03\x12\
    \x03\tCO\n\x0b\n\x04\x06\0\x02\x02\x12\x03\n\x04;\n\x0c\n\x05\x06\0\x02\
    \x02\x01\x12\x03\n\x08\x1b\n\x0c\n\x05\x06\0\x02\x02\x05\x12\x03\n\x1d#\
    \n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03\n$)\n\x0c\n\x05\x06\0\x02\x02\x03\
    \x12\x03\n49\n\n\n\x02\x04\x01\x12\x04\r\0\x10\x01\n\n\n\x03\x04\x01\x01\
    \x12\x03\r\x08\x1e\n\x0b\n\x04\x04\x01\x02\0\x12\x03\x0e\x04\x14\n\r\n\
    \x05\x04\x01\x02\0\x04\x12\x04\x0e\x04\r\x20\n\x0c\n\x05\x04\x01\x02\0\
    \x05\x12\x03\x0e\x04\n\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\x0e\x0b\x0f\
    \n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x0e\x12\x13\n\x0b\n\x04\x04\x01\
    \x02\x01\x12\x03\x0f\x04\x18\n\r\n\x05\x04\x01\x02\x01\x04\x12\x04\x0f\
    \x04\x0e\x14\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03\x0f\x04\n\n\x0c\n\
    \x05\x04\x01\x02\x01\x01\x12\x03\x0f\x0b\x13\n\x0c\n\x05\x04\x01\x02\x01\
    \x03\x12\x03\x0f\x16\x17\n\n\n\x02\x04\x02\x12\x04\x12\0\x17\x01\n\n\n\
    \x03\x04\x02\x01\x12\x03\x12\x08\x14\n\x0b\n\x04\x04\x02\x02\0\x12\x03\
    \x13\x04\x14\n\r\n\x05\x04\x02\x02\0\x04\x12\x04\x13\x04\x12\x16\n\x0c\n\
    \x05\x04\x02\x02\0\x05\x12\x03\x13\x04\t\n\x0c\n\x05\x04\x02\x02\0\x01\
    \x12\x03\x13\n\x0f\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03\x13\x12\x13\n\
    \x0c\n\x04\x04\x02\x08\0\x12\x04\x14\x04\x16\x05\n\x0c\n\x05\x04\x02\x08\
    \0\x01\x12\x03\x14\n\x0e\n\x0b\n\x04\x04\x02\x02\x01\x12\x03\x15\x08*\n\
    \x0c\n\x05\x04\x02\x02\x01\x06\x12\x03\x15\x08\x19\n\x0c\n\x05\x04\x02\
    \x02\x01\x01\x12\x03\x15\x1a%\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03\
    \x15()\n\n\n\x02\x04\x03\x12\x04\x19\0\x1f\x01\n\n\n\x03\x04\x03\x01\x12\
    \x03\x19\x08\x15\n\x0b\n\x04\x04\x03\x02\0\x12\x03\x1a\x04\x14\n\r\n\x05\
    \x04\x03\x02\0\x04\x12\x04\x1a\x04\x19\x17\n\x0c\n\x05\x04\x03\x02\0\x05\
    \x12\x03\x1a\x04\t\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03\x1a\n\x0f\n\x0c\
    \n\x05\x04\x03\x02\0\x03\x12\x03\x1a\x12\x13\n\x0c\n\x04\x04\x03\x08\0\
    \x12\x04\x1b\x04\x1e\x05\n\x0c\n\x05\x04\x03\x08\0\x01\x12\x03\x1b\n\x0e\
    \n\x0b\n\x04\x04\x03\x02\x01\x12\x03\x1c\x08%\n\x0c\n\x05\x04\x03\x02\
    \x01\x06\x12\x03\x1c\x08\x1a\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03\x1c\
    \x1b\x20\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03\x1c#$\n\x0b\n\x04\x04\
    \x03\x02\x02\x12\x03\x1d\x08+\n\x0c\n\x05\x04\x03\x02\x02\x06\x12\x03\
    \x1d\x08\x1a\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x03\x1d\x1b&\n\x0c\n\
    \x05\x04\x03\x02\x02\x03\x12\x03\x1d)*\n\n\n\x02\x04\x04\x12\x04!\0#\x01\
    \n\n\n\x03\x04\x04\x01\x12\x03!\x08\x1a\n\x0b\n\x04\x04\x04\x02\0\x12\
    \x03\"\x04\x17\n\r\n\x05\x04\x04\x02\0\x04\x12\x04\"\x04!\x1c\n\x0c\n\
    \x05\x04\x04\x02\0\x05\x12\x03\"\x04\n\n\x0c\n\x05\x04\x04\x02\0\x01\x12\
    \x03\"\x0b\x12\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03\"\x15\x16\n\n\n\x02\
    \x04\x05\x12\x04%\0'\x01\n\n\n\x03\x04\x05\x01\x12\x03%\x08\x19\n\x0b\n\
    \x04\x04\x05\x02\0\x12\x03&\x045\n\r\n\x05\x04\x05\x02\0\x04\x12\x04&\
    \x04%\x1b\n\x0c\n\x05\x04\x05\x02\0\x06\x12\x03&\x04\x1d\n\x0c\n\x05\x04\
    \x05\x02\0\x01\x12\x03&\x1e0\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03&34\n\
    \n\n\x02\x04\x06\x12\x04)\0+\x01\n\n\n\x03\x04\x06\x01\x12\x03)\x08\x1a\
    \n\x0b\n\x04\x04\x06\x02\0\x12\x03*\x04\x1e\n\x0c\n\x05\x04\x06\x02\0\
    \x04\x12\x03*\x04\x0c\n\x0c\n\x05\x04\x06\x02\0\x06\x12\x03*\r\x12\n\x0c\
    \n\x05\x04\x06\x02\0\x01\x12\x03*\x13\x19\n\x0c\n\x05\x04\x06\x02\0\x03\
    \x12\x03*\x1c\x1d\n\n\n\x02\x04\x07\x12\x04-\00\x01\n\n\n\x03\x04\x07\
    \x01\x12\x03-\x08\x10\n\x0b\n\x04\x04\x07\x02\0\x12\x03.\x04\x11\n\r\n\
    \x05\x04\x07\x02\0\x04\x12\x04.\x04-\x12\n\x0c\n\x05\x04\x07\x02\0\x05\
    \x12\x03.\x04\t\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03.\n\x0c\n\x0c\n\x05\
    \x04\x07\x02\0\x03\x12\x03.\x0f\x10\n\x0b\n\x04\x04\x07\x02\x01\x12\x03/\
    \x04\x14\n\r\n\x05\x04\x07\x02\x01\x04\x12\x04/\x04.\x11\n\x0c\n\x05\x04\
    \x07\x02\x01\x05\x12\x03/\x04\n\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03/\
    \x0b\x0f\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x03/\x12\x13\n\n\n\x02\x04\
    \x08\x12\x042\05\x01\n\n\n\x03\x04\x08\x01\x12\x032\x08\x12\n\x0b\n\x04\
    \x04\x08\x02\0\x12\x033\x04\x11\n\r\n\x05\x04\x08\x02\0\x04\x12\x043\x04\
    2\x14\n\x0c\n\x05\x04\x08\x02\0\x05\x12\x033\x04\t\n\x0c\n\x05\x04\x08\
    \x02\0\x01\x12\x033\n\x0c\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x033\x0f\x10\
    \n\x0b\n\x04\x04\x08\x02\x01\x12\x034\x04\x14\n\r\n\x05\x04\x08\x02\x01\
    \x04\x12\x044\x043\x11\n\x0c\n\x05\x04\x08\x02\x01\x05\x12\x034\x04\n\n\
    \x0c\n\x05\x04\x08\x02\x01\x01\x12\x034\x0b\x0f\n\x0c\n\x05\x04\x08\x02\
    \x01\x03\x12\x034\x12\x13\n\n\n\x02\x04\t\x12\x047\0:\x01\n\n\n\x03\x04\
    \t\x01\x12\x037\x08\r\n\x0b\n\x04\x04\t\x02\0\x12\x038\x04\x11\n\r\n\x05\
    \x04\t\x02\0\x04\x12\x048\x047\x0f\n\x0c\n\x05\x04\t\x02\0\x05\x12\x038\
    \x04\t\n\x0c\n\x05\x04\t\x02\0\x01\x12\x038\n\x0c\n\x0c\n\x05\x04\t\x02\
    \0\x03\x12\x038\x0f\x10\n\x0b\n\x04\x04\t\x02\x01\x12\x039\x04\x14\n\r\n\
    \x05\x04\t\x02\x01\x04\x12\x049\x048\x11\n\x0c\n\x05\x04\t\x02\x01\x05\
    \x12\x039\x04\n\n\x0c\n\x05\x04\t\x02\x01\x01\x12\x039\x0b\x0f\n\x0c\n\
    \x05\x04\t\x02\x01\x03\x12\x039\x12\x13\n\n\n\x02\x04\n\x12\x04<\0B\x01\
    \n\n\n\x03\x04\n\x01\x12\x03<\x08\x11\n\x0c\n\x04\x04\n\x08\0\x12\x04=\
    \x04A\x05\n\x0c\n\x05\x04\n\x08\0\x01\x12\x03=\n\x0e\n\x0b\n\x04\x04\n\
    \x02\0\x12\x03>\x08\"\n\x0c\n\x05\x04\n\x02\0\x06\x12\x03>\x08\x12\n\x0c\
    \n\x05\x04\n\x02\0\x01\x12\x03>\x13\x1d\n\x0c\n\x05\x04\n\x02\0\x03\x12\
    \x03>\x20!\n\x0b\n\x04\x04\n\x02\x01\x12\x03?\x08\x19\n\x0c\n\x05\x04\n\
    \x02\x01\x05\x12\x03?\x08\x0c\n\x0c\n\x05\x04\n\x02\x01\x01\x12\x03?\r\
    \x14\n\x0c\n\x05\x04\n\x02\x01\x03\x12\x03?\x17\x18\n\x0b\n\x04\x04\n\
    \x02\x02\x12\x03@\x08\x18\n\x0c\n\x05\x04\n\x02\x02\x05\x12\x03@\x08\x0c\
    \n\x0c\n\x05\x04\n\x02\x02\x01\x12\x03@\r\x13\n\x0c\n\x05\x04\n\x02\x02\
    \x03\x12\x03@\x16\x17\n\n\n\x02\x04\x0b\x12\x04D\0K\x01\n\n\n\x03\x04\
    \x0b\x01\x12\x03D\x08\x0f\n\x0b\n\x04\x04\x0b\x02\0\x12\x03E\x04\x1c\n\r\
    \n\x05\x04\x0b\x02\0\x04\x12\x04E\x04D\x11\n\x0c\n\x05\x04\x0b\x02\0\x06\
    \x12\x03E\x04\r\n\x0c\n\x05\x04\x0b\x02\0\x01\x12\x03E\x0e\x17\n\x0c\n\
    \x05\x04\x0b\x02\0\x03\x12\x03E\x1a\x1b\n\x0b\n\x04\x04\x0b\x02\x01\x12\
    \x03F\x04%\n\r\n\x05\x04\x0b\x02\x01\x04\x12\x04F\x04E\x1c\n\x0c\n\x05\
    \x04\x0b\x02\x01\x06\x12\x03F\x04\x1d\n\x0c\n\x05\x04\x0b\x02\x01\x01\
    \x12\x03F\x1e\x20\n\x0c\n\x05\x04\x0b\x02\x01\x03\x12\x03F#$\n\x0c\n\x04\
    \x04\x0b\x08\0\x12\x04G\x04J\x05\n\x0c\n\x05\x04\x0b\x08\0\x01\x12\x03G\
    \n\x11\n\x0b\n\x04\x04\x0b\x02\x02\x12\x03H\x08\x18\n\x0c\n\x05\x04\x0b\
    \x02\x02\x05\x12\x03H\x08\x0e\n\x0c\n\x05\x04\x0b\x02\x02\x01\x12\x03H\
    \x0f\x13\n\x0c\n\x05\x04\x0b\x02\x02\x03\x12\x03H\x16\x17\n\x0b\n\x04\
    \x04\x0b\x02\x03\x12\x03I\x08\x18\n\x0c\n\x05\x04\x0b\x02\x03\x05\x12\
    \x03I\x08\x0e\n\x0c\n\x05\x04\x0b\x02\x03\x01\x12\x03I\x0f\x13\n\x0c\n\
    \x05\x04\x0b\x02\x03\x03\x12\x03I\x16\x17\n\n\n\x02\x04\x0c\x12\x04M\0U\
    \x01\n\n\n\x03\x04\x0c\x01\x12\x03M\x08\r\n\x0c\n\x04\x04\x0c\x08\0\x12\
    \x04N\x04R\x05\n\x0c\n\x05\x04\x0c\x08\0\x01\x12\x03N\n\x0e\n\x0b\n\x04\
    \x04\x0c\x02\0\x12\x03O\x08\"\n\x0c\n\x05\x04\x0c\x02\0\x06\x12\x03O\x08\
    \x12\n\x0c\n\x05\x04\x0c\x02\0\x01\x12\x03O\x13\x1d\n\x0c\n\x05\x04\x0c\
    \x02\0\x03\x12\x03O\x20!\n\x0b\n\x04\x04\x0c\x02\x01\x12\x03P\x08\x18\n\
    \x0c\n\x05\x04\x0c\x02\x01\x06\x12\x03P\x08\r\n\x0c\n\x05\x04\x0c\x02\
    \x01\x01\x12\x03P\x0e\x13\n\x0c\n\x05\x04\x0c\x02\x01\x03\x12\x03P\x16\
    \x17\n\x0b\n\x04\x04\x0c\x02\x02\x12\x03Q\x08\x19\n\x0c\n\x05\x04\x0c\
    \x02\x02\x05\x12\x03Q\x08\x0c\n\x0c\n\x05\x04\x0c\x02\x02\x01\x12\x03Q\r\
    \x14\n\x0c\n\x05\x04\x0c\x02\x02\x03\x12\x03Q\x17\x18\n\x0b\n\x04\x04\
    \x0c\x02\x03\x12\x03S\x04\x1a\n\r\n\x05\x04\x0c\x02\x03\x04\x12\x04S\x04\
    R\x05\n\x0c\n\x05\x04\x0c\x02\x03\x06\x12\x03S\x04\x0c\n\x0c\n\x05\x04\
    \x0c\x02\x03\x01\x12\x03S\r\x15\n\x0c\n\x05\x04\x0c\x02\x03\x03\x12\x03S\
    \x18\x19\n\x0b\n\x04\x04\x0c\x02\x04\x12\x03T\x04\x1d\n\r\n\x05\x04\x0c\
    \x02\x04\x04\x12\x04T\x04S\x1a\n\x0c\n\x05\x04\x0c\x02\x04\x06\x12\x03T\
    \x04\x0b\n\x0c\n\x05\x04\x0c\x02\x04\x01\x12\x03T\x0c\x18\n\x0c\n\x05\
    \x04\x0c\x02\x04\x03\x12\x03T\x1b\x1cb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
