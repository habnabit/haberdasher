// This file is generated by rust-protobuf 2.1.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct Empty {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Empty {
    pub fn new() -> Empty {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Empty {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Empty {
        Empty::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Empty>(
                    "Empty",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Empty {
        static mut instance: ::protobuf::lazy::Lazy<Empty> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Empty,
        };
        unsafe {
            instance.get(Empty::new)
        }
    }
}

impl ::protobuf::Clear for Empty {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Empty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Empty {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AgentRequest {
    // message fields
    pub seqno: i64,
    // message oneof groups
    pub kind: ::std::option::Option<AgentRequest_oneof_kind>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum AgentRequest_oneof_kind {
    list_venues(ListVenuesRequest),
}

impl AgentRequest {
    pub fn new() -> AgentRequest {
        ::std::default::Default::default()
    }

    // int64 seqno = 1;

    pub fn clear_seqno(&mut self) {
        self.seqno = 0;
    }

    // Param is passed by value, moved
    pub fn set_seqno(&mut self, v: i64) {
        self.seqno = v;
    }

    pub fn get_seqno(&self) -> i64 {
        self.seqno
    }

    // .haberdasher.ListVenuesRequest list_venues = 2;

    pub fn clear_list_venues(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_list_venues(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(AgentRequest_oneof_kind::list_venues(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_list_venues(&mut self, v: ListVenuesRequest) {
        self.kind = ::std::option::Option::Some(AgentRequest_oneof_kind::list_venues(v))
    }

    // Mutable pointer to the field.
    pub fn mut_list_venues(&mut self) -> &mut ListVenuesRequest {
        if let ::std::option::Option::Some(AgentRequest_oneof_kind::list_venues(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(AgentRequest_oneof_kind::list_venues(ListVenuesRequest::new()));
        }
        match self.kind {
            ::std::option::Option::Some(AgentRequest_oneof_kind::list_venues(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_list_venues(&mut self) -> ListVenuesRequest {
        if self.has_list_venues() {
            match self.kind.take() {
                ::std::option::Option::Some(AgentRequest_oneof_kind::list_venues(v)) => v,
                _ => panic!(),
            }
        } else {
            ListVenuesRequest::new()
        }
    }

    pub fn get_list_venues(&self) -> &ListVenuesRequest {
        match self.kind {
            ::std::option::Option::Some(AgentRequest_oneof_kind::list_venues(ref v)) => v,
            _ => ListVenuesRequest::default_instance(),
        }
    }
}

impl ::protobuf::Message for AgentRequest {
    fn is_initialized(&self) -> bool {
        if let Some(AgentRequest_oneof_kind::list_venues(ref v)) = self.kind {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.seqno = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(AgentRequest_oneof_kind::list_venues(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.seqno != 0 {
            my_size += ::protobuf::rt::value_size(1, self.seqno, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.kind {
            match v {
                &AgentRequest_oneof_kind::list_venues(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.seqno != 0 {
            os.write_int64(1, self.seqno)?;
        }
        if let ::std::option::Option::Some(ref v) = self.kind {
            match v {
                &AgentRequest_oneof_kind::list_venues(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AgentRequest {
        AgentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "seqno",
                    |m: &AgentRequest| { &m.seqno },
                    |m: &mut AgentRequest| { &mut m.seqno },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ListVenuesRequest>(
                    "list_venues",
                    AgentRequest::has_list_venues,
                    AgentRequest::get_list_venues,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AgentRequest>(
                    "AgentRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AgentRequest {
        static mut instance: ::protobuf::lazy::Lazy<AgentRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AgentRequest,
        };
        unsafe {
            instance.get(AgentRequest::new)
        }
    }
}

impl ::protobuf::Clear for AgentRequest {
    fn clear(&mut self) {
        self.clear_seqno();
        self.clear_list_venues();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AgentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AgentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AgentResponse {
    // message fields
    pub seqno: i64,
    // message oneof groups
    pub kind: ::std::option::Option<AgentResponse_oneof_kind>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum AgentResponse_oneof_kind {
    error(AgentErrorResponse),
    list_venues(ListVenuesResponse),
}

impl AgentResponse {
    pub fn new() -> AgentResponse {
        ::std::default::Default::default()
    }

    // int64 seqno = 1;

    pub fn clear_seqno(&mut self) {
        self.seqno = 0;
    }

    // Param is passed by value, moved
    pub fn set_seqno(&mut self, v: i64) {
        self.seqno = v;
    }

    pub fn get_seqno(&self) -> i64 {
        self.seqno
    }

    // .haberdasher.AgentErrorResponse error = 2;

    pub fn clear_error(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(AgentResponse_oneof_kind::error(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: AgentErrorResponse) {
        self.kind = ::std::option::Option::Some(AgentResponse_oneof_kind::error(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error(&mut self) -> &mut AgentErrorResponse {
        if let ::std::option::Option::Some(AgentResponse_oneof_kind::error(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(AgentResponse_oneof_kind::error(AgentErrorResponse::new()));
        }
        match self.kind {
            ::std::option::Option::Some(AgentResponse_oneof_kind::error(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error(&mut self) -> AgentErrorResponse {
        if self.has_error() {
            match self.kind.take() {
                ::std::option::Option::Some(AgentResponse_oneof_kind::error(v)) => v,
                _ => panic!(),
            }
        } else {
            AgentErrorResponse::new()
        }
    }

    pub fn get_error(&self) -> &AgentErrorResponse {
        match self.kind {
            ::std::option::Option::Some(AgentResponse_oneof_kind::error(ref v)) => v,
            _ => AgentErrorResponse::default_instance(),
        }
    }

    // .haberdasher.ListVenuesResponse list_venues = 3;

    pub fn clear_list_venues(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_list_venues(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(AgentResponse_oneof_kind::list_venues(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_list_venues(&mut self, v: ListVenuesResponse) {
        self.kind = ::std::option::Option::Some(AgentResponse_oneof_kind::list_venues(v))
    }

    // Mutable pointer to the field.
    pub fn mut_list_venues(&mut self) -> &mut ListVenuesResponse {
        if let ::std::option::Option::Some(AgentResponse_oneof_kind::list_venues(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(AgentResponse_oneof_kind::list_venues(ListVenuesResponse::new()));
        }
        match self.kind {
            ::std::option::Option::Some(AgentResponse_oneof_kind::list_venues(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_list_venues(&mut self) -> ListVenuesResponse {
        if self.has_list_venues() {
            match self.kind.take() {
                ::std::option::Option::Some(AgentResponse_oneof_kind::list_venues(v)) => v,
                _ => panic!(),
            }
        } else {
            ListVenuesResponse::new()
        }
    }

    pub fn get_list_venues(&self) -> &ListVenuesResponse {
        match self.kind {
            ::std::option::Option::Some(AgentResponse_oneof_kind::list_venues(ref v)) => v,
            _ => ListVenuesResponse::default_instance(),
        }
    }
}

impl ::protobuf::Message for AgentResponse {
    fn is_initialized(&self) -> bool {
        if let Some(AgentResponse_oneof_kind::error(ref v)) = self.kind {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(AgentResponse_oneof_kind::list_venues(ref v)) = self.kind {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.seqno = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(AgentResponse_oneof_kind::error(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(AgentResponse_oneof_kind::list_venues(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.seqno != 0 {
            my_size += ::protobuf::rt::value_size(1, self.seqno, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.kind {
            match v {
                &AgentResponse_oneof_kind::error(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &AgentResponse_oneof_kind::list_venues(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.seqno != 0 {
            os.write_int64(1, self.seqno)?;
        }
        if let ::std::option::Option::Some(ref v) = self.kind {
            match v {
                &AgentResponse_oneof_kind::error(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &AgentResponse_oneof_kind::list_venues(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AgentResponse {
        AgentResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "seqno",
                    |m: &AgentResponse| { &m.seqno },
                    |m: &mut AgentResponse| { &mut m.seqno },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AgentErrorResponse>(
                    "error",
                    AgentResponse::has_error,
                    AgentResponse::get_error,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ListVenuesResponse>(
                    "list_venues",
                    AgentResponse::has_list_venues,
                    AgentResponse::get_list_venues,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AgentResponse>(
                    "AgentResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AgentResponse {
        static mut instance: ::protobuf::lazy::Lazy<AgentResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AgentResponse,
        };
        unsafe {
            instance.get(AgentResponse::new)
        }
    }
}

impl ::protobuf::Clear for AgentResponse {
    fn clear(&mut self) {
        self.clear_seqno();
        self.clear_error();
        self.clear_list_venues();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AgentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AgentResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AgentErrorResponse {
    // message fields
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl AgentErrorResponse {
    pub fn new() -> AgentErrorResponse {
        ::std::default::Default::default()
    }

    // string message = 1;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        &self.message
    }
}

impl ::protobuf::Message for AgentErrorResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AgentErrorResponse {
        AgentErrorResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &AgentErrorResponse| { &m.message },
                    |m: &mut AgentErrorResponse| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AgentErrorResponse>(
                    "AgentErrorResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AgentErrorResponse {
        static mut instance: ::protobuf::lazy::Lazy<AgentErrorResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AgentErrorResponse,
        };
        unsafe {
            instance.get(AgentErrorResponse::new)
        }
    }
}

impl ::protobuf::Clear for AgentErrorResponse {
    fn clear(&mut self) {
        self.clear_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AgentErrorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AgentErrorResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListVenuesRequest {
    // message fields
    pub with_updates_since: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ListVenuesRequest {
    pub fn new() -> ListVenuesRequest {
        ::std::default::Default::default()
    }

    // .google.protobuf.Timestamp with_updates_since = 1;

    pub fn clear_with_updates_since(&mut self) {
        self.with_updates_since.clear();
    }

    pub fn has_with_updates_since(&self) -> bool {
        self.with_updates_since.is_some()
    }

    // Param is passed by value, moved
    pub fn set_with_updates_since(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.with_updates_since = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_with_updates_since(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.with_updates_since.is_none() {
            self.with_updates_since.set_default();
        }
        self.with_updates_since.as_mut().unwrap()
    }

    // Take field
    pub fn take_with_updates_since(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.with_updates_since.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_with_updates_since(&self) -> &::protobuf::well_known_types::Timestamp {
        self.with_updates_since.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
}

impl ::protobuf::Message for ListVenuesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.with_updates_since {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.with_updates_since)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.with_updates_since.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.with_updates_since.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListVenuesRequest {
        ListVenuesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "with_updates_since",
                    |m: &ListVenuesRequest| { &m.with_updates_since },
                    |m: &mut ListVenuesRequest| { &mut m.with_updates_since },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListVenuesRequest>(
                    "ListVenuesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListVenuesRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListVenuesRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListVenuesRequest,
        };
        unsafe {
            instance.get(ListVenuesRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListVenuesRequest {
    fn clear(&mut self) {
        self.clear_with_updates_since();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListVenuesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListVenuesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListVenuesResponse {
    // message fields
    pub venues: ::protobuf::RepeatedField<Venue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ListVenuesResponse {
    pub fn new() -> ListVenuesResponse {
        ::std::default::Default::default()
    }

    // repeated .haberdasher.Venue venues = 1;

    pub fn clear_venues(&mut self) {
        self.venues.clear();
    }

    // Param is passed by value, moved
    pub fn set_venues(&mut self, v: ::protobuf::RepeatedField<Venue>) {
        self.venues = v;
    }

    // Mutable pointer to the field.
    pub fn mut_venues(&mut self) -> &mut ::protobuf::RepeatedField<Venue> {
        &mut self.venues
    }

    // Take field
    pub fn take_venues(&mut self) -> ::protobuf::RepeatedField<Venue> {
        ::std::mem::replace(&mut self.venues, ::protobuf::RepeatedField::new())
    }

    pub fn get_venues(&self) -> &[Venue] {
        &self.venues
    }
}

impl ::protobuf::Message for ListVenuesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.venues {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.venues)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.venues {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.venues {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListVenuesResponse {
        ListVenuesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Venue>>(
                    "venues",
                    |m: &ListVenuesResponse| { &m.venues },
                    |m: &mut ListVenuesResponse| { &mut m.venues },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListVenuesResponse>(
                    "ListVenuesResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListVenuesResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListVenuesResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListVenuesResponse,
        };
        unsafe {
            instance.get(ListVenuesResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListVenuesResponse {
    fn clear(&mut self) {
        self.clear_venues();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListVenuesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListVenuesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Agent {
    // message fields
    pub name: ::std::string::String,
    pub version: ::std::string::String,
    pub revision: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Agent {
    pub fn new() -> Agent {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }

    // string version = 2;

    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    pub fn get_version(&self) -> &str {
        &self.version
    }

    // string revision = 3;

    pub fn clear_revision(&mut self) {
        self.revision.clear();
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: ::std::string::String) {
        self.revision = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_revision(&mut self) -> &mut ::std::string::String {
        &mut self.revision
    }

    // Take field
    pub fn take_revision(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.revision, ::std::string::String::new())
    }

    pub fn get_revision(&self) -> &str {
        &self.revision
    }
}

impl ::protobuf::Message for Agent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.revision)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.version);
        }
        if !self.revision.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.revision);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.version.is_empty() {
            os.write_string(2, &self.version)?;
        }
        if !self.revision.is_empty() {
            os.write_string(3, &self.revision)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Agent {
        Agent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Agent| { &m.name },
                    |m: &mut Agent| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "version",
                    |m: &Agent| { &m.version },
                    |m: &mut Agent| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "revision",
                    |m: &Agent| { &m.revision },
                    |m: &mut Agent| { &mut m.revision },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Agent>(
                    "Agent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Agent {
        static mut instance: ::protobuf::lazy::Lazy<Agent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Agent,
        };
        unsafe {
            instance.get(Agent::new)
        }
    }
}

impl ::protobuf::Clear for Agent {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_version();
        self.clear_revision();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Agent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Agent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Individual {
    // message fields
    pub id: ::std::string::String,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Individual {
    pub fn new() -> Individual {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    pub fn get_id(&self) -> &str {
        &self.id
    }

    // string name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }
}

impl ::protobuf::Message for Individual {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Individual {
        Individual::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &Individual| { &m.id },
                    |m: &mut Individual| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Individual| { &m.name },
                    |m: &mut Individual| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Individual>(
                    "Individual",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Individual {
        static mut instance: ::protobuf::lazy::Lazy<Individual> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Individual,
        };
        unsafe {
            instance.get(Individual::new)
        }
    }
}

impl ::protobuf::Clear for Individual {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Individual {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Individual {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Group {
    // message fields
    pub id: ::std::string::String,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Group {
    pub fn new() -> Group {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    pub fn get_id(&self) -> &str {
        &self.id
    }

    // string name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }
}

impl ::protobuf::Message for Group {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Group {
        Group::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &Group| { &m.id },
                    |m: &mut Group| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Group| { &m.name },
                    |m: &mut Group| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Group>(
                    "Group",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Group {
        static mut instance: ::protobuf::lazy::Lazy<Group> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Group,
        };
        unsafe {
            instance.get(Group::new)
        }
    }
}

impl ::protobuf::Clear for Group {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Group {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Group {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Performer {
    // message oneof groups
    pub kind: ::std::option::Option<Performer_oneof_kind>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum Performer_oneof_kind {
    individual(Individual),
    service(bool),
    myself(bool),
}

impl Performer {
    pub fn new() -> Performer {
        ::std::default::Default::default()
    }

    // .haberdasher.Individual individual = 1;

    pub fn clear_individual(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_individual(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(Performer_oneof_kind::individual(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_individual(&mut self, v: Individual) {
        self.kind = ::std::option::Option::Some(Performer_oneof_kind::individual(v))
    }

    // Mutable pointer to the field.
    pub fn mut_individual(&mut self) -> &mut Individual {
        if let ::std::option::Option::Some(Performer_oneof_kind::individual(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(Performer_oneof_kind::individual(Individual::new()));
        }
        match self.kind {
            ::std::option::Option::Some(Performer_oneof_kind::individual(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_individual(&mut self) -> Individual {
        if self.has_individual() {
            match self.kind.take() {
                ::std::option::Option::Some(Performer_oneof_kind::individual(v)) => v,
                _ => panic!(),
            }
        } else {
            Individual::new()
        }
    }

    pub fn get_individual(&self) -> &Individual {
        match self.kind {
            ::std::option::Option::Some(Performer_oneof_kind::individual(ref v)) => v,
            _ => Individual::default_instance(),
        }
    }

    // bool service = 2;

    pub fn clear_service(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_service(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(Performer_oneof_kind::service(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: bool) {
        self.kind = ::std::option::Option::Some(Performer_oneof_kind::service(v))
    }

    pub fn get_service(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(Performer_oneof_kind::service(v)) => v,
            _ => false,
        }
    }

    // bool myself = 3;

    pub fn clear_myself(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_myself(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(Performer_oneof_kind::myself(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_myself(&mut self, v: bool) {
        self.kind = ::std::option::Option::Some(Performer_oneof_kind::myself(v))
    }

    pub fn get_myself(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(Performer_oneof_kind::myself(v)) => v,
            _ => false,
        }
    }
}

impl ::protobuf::Message for Performer {
    fn is_initialized(&self) -> bool {
        if let Some(Performer_oneof_kind::individual(ref v)) = self.kind {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(Performer_oneof_kind::individual(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(Performer_oneof_kind::service(is.read_bool()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(Performer_oneof_kind::myself(is.read_bool()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.kind {
            match v {
                &Performer_oneof_kind::individual(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Performer_oneof_kind::service(v) => {
                    my_size += 2;
                },
                &Performer_oneof_kind::myself(v) => {
                    my_size += 2;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.kind {
            match v {
                &Performer_oneof_kind::individual(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Performer_oneof_kind::service(v) => {
                    os.write_bool(2, v)?;
                },
                &Performer_oneof_kind::myself(v) => {
                    os.write_bool(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Performer {
        Performer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Individual>(
                    "individual",
                    Performer::has_individual,
                    Performer::get_individual,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                    "service",
                    Performer::has_service,
                    Performer::get_service,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                    "myself",
                    Performer::has_myself,
                    Performer::get_myself,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Performer>(
                    "Performer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Performer {
        static mut instance: ::protobuf::lazy::Lazy<Performer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Performer,
        };
        unsafe {
            instance.get(Performer::new)
        }
    }
}

impl ::protobuf::Clear for Performer {
    fn clear(&mut self) {
        self.clear_individual();
        self.clear_service();
        self.clear_myself();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Performer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Performer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Origin {
    // message fields
    pub path: ::protobuf::RepeatedField<Origin_Segment>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Origin {
    pub fn new() -> Origin {
        ::std::default::Default::default()
    }

    // repeated .haberdasher.Origin.Segment path = 1;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::protobuf::RepeatedField<Origin_Segment>) {
        self.path = v;
    }

    // Mutable pointer to the field.
    pub fn mut_path(&mut self) -> &mut ::protobuf::RepeatedField<Origin_Segment> {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::protobuf::RepeatedField<Origin_Segment> {
        ::std::mem::replace(&mut self.path, ::protobuf::RepeatedField::new())
    }

    pub fn get_path(&self) -> &[Origin_Segment] {
        &self.path
    }
}

impl ::protobuf::Message for Origin {
    fn is_initialized(&self) -> bool {
        for v in &self.path {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.path {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.path {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Origin {
        Origin::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Origin_Segment>>(
                    "path",
                    |m: &Origin| { &m.path },
                    |m: &mut Origin| { &mut m.path },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Origin>(
                    "Origin",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Origin {
        static mut instance: ::protobuf::lazy::Lazy<Origin> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Origin,
        };
        unsafe {
            instance.get(Origin::new)
        }
    }
}

impl ::protobuf::Clear for Origin {
    fn clear(&mut self) {
        self.clear_path();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Origin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Origin {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Origin_Segment {
    // message fields
    pub individual: ::protobuf::SingularPtrField<Individual>,
    pub group: ::protobuf::SingularPtrField<Group>,
    pub service: bool,
    pub service_instance: ::std::string::String,
    pub myself: bool,
    pub themself: bool,
    pub agent: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Origin_Segment {
    pub fn new() -> Origin_Segment {
        ::std::default::Default::default()
    }

    // .haberdasher.Individual individual = 1;

    pub fn clear_individual(&mut self) {
        self.individual.clear();
    }

    pub fn has_individual(&self) -> bool {
        self.individual.is_some()
    }

    // Param is passed by value, moved
    pub fn set_individual(&mut self, v: Individual) {
        self.individual = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_individual(&mut self) -> &mut Individual {
        if self.individual.is_none() {
            self.individual.set_default();
        }
        self.individual.as_mut().unwrap()
    }

    // Take field
    pub fn take_individual(&mut self) -> Individual {
        self.individual.take().unwrap_or_else(|| Individual::new())
    }

    pub fn get_individual(&self) -> &Individual {
        self.individual.as_ref().unwrap_or_else(|| Individual::default_instance())
    }

    // .haberdasher.Group group = 2;

    pub fn clear_group(&mut self) {
        self.group.clear();
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: Group) {
        self.group = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut Group {
        if self.group.is_none() {
            self.group.set_default();
        }
        self.group.as_mut().unwrap()
    }

    // Take field
    pub fn take_group(&mut self) -> Group {
        self.group.take().unwrap_or_else(|| Group::new())
    }

    pub fn get_group(&self) -> &Group {
        self.group.as_ref().unwrap_or_else(|| Group::default_instance())
    }

    // bool service = 3;

    pub fn clear_service(&mut self) {
        self.service = false;
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: bool) {
        self.service = v;
    }

    pub fn get_service(&self) -> bool {
        self.service
    }

    // string service_instance = 4;

    pub fn clear_service_instance(&mut self) {
        self.service_instance.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_instance(&mut self, v: ::std::string::String) {
        self.service_instance = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_instance(&mut self) -> &mut ::std::string::String {
        &mut self.service_instance
    }

    // Take field
    pub fn take_service_instance(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_instance, ::std::string::String::new())
    }

    pub fn get_service_instance(&self) -> &str {
        &self.service_instance
    }

    // bool myself = 5;

    pub fn clear_myself(&mut self) {
        self.myself = false;
    }

    // Param is passed by value, moved
    pub fn set_myself(&mut self, v: bool) {
        self.myself = v;
    }

    pub fn get_myself(&self) -> bool {
        self.myself
    }

    // bool themself = 6;

    pub fn clear_themself(&mut self) {
        self.themself = false;
    }

    // Param is passed by value, moved
    pub fn set_themself(&mut self, v: bool) {
        self.themself = v;
    }

    pub fn get_themself(&self) -> bool {
        self.themself
    }

    // string agent = 7;

    pub fn clear_agent(&mut self) {
        self.agent.clear();
    }

    // Param is passed by value, moved
    pub fn set_agent(&mut self, v: ::std::string::String) {
        self.agent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_agent(&mut self) -> &mut ::std::string::String {
        &mut self.agent
    }

    // Take field
    pub fn take_agent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.agent, ::std::string::String::new())
    }

    pub fn get_agent(&self) -> &str {
        &self.agent
    }
}

impl ::protobuf::Message for Origin_Segment {
    fn is_initialized(&self) -> bool {
        for v in &self.individual {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.group {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.individual)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.group)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.service = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_instance)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.myself = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.themself = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.agent)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.individual.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.group.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.service != false {
            my_size += 2;
        }
        if !self.service_instance.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.service_instance);
        }
        if self.myself != false {
            my_size += 2;
        }
        if self.themself != false {
            my_size += 2;
        }
        if !self.agent.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.agent);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.individual.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.group.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.service != false {
            os.write_bool(3, self.service)?;
        }
        if !self.service_instance.is_empty() {
            os.write_string(4, &self.service_instance)?;
        }
        if self.myself != false {
            os.write_bool(5, self.myself)?;
        }
        if self.themself != false {
            os.write_bool(6, self.themself)?;
        }
        if !self.agent.is_empty() {
            os.write_string(7, &self.agent)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Origin_Segment {
        Origin_Segment::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Individual>>(
                    "individual",
                    |m: &Origin_Segment| { &m.individual },
                    |m: &mut Origin_Segment| { &mut m.individual },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Group>>(
                    "group",
                    |m: &Origin_Segment| { &m.group },
                    |m: &mut Origin_Segment| { &mut m.group },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "service",
                    |m: &Origin_Segment| { &m.service },
                    |m: &mut Origin_Segment| { &mut m.service },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "service_instance",
                    |m: &Origin_Segment| { &m.service_instance },
                    |m: &mut Origin_Segment| { &mut m.service_instance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "myself",
                    |m: &Origin_Segment| { &m.myself },
                    |m: &mut Origin_Segment| { &mut m.myself },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "themself",
                    |m: &Origin_Segment| { &m.themself },
                    |m: &mut Origin_Segment| { &mut m.themself },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "agent",
                    |m: &Origin_Segment| { &m.agent },
                    |m: &mut Origin_Segment| { &mut m.agent },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Origin_Segment>(
                    "Origin_Segment",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Origin_Segment {
        static mut instance: ::protobuf::lazy::Lazy<Origin_Segment> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Origin_Segment,
        };
        unsafe {
            instance.get(Origin_Segment::new)
        }
    }
}

impl ::protobuf::Clear for Origin_Segment {
    fn clear(&mut self) {
        self.clear_individual();
        self.clear_group();
        self.clear_service();
        self.clear_service_instance();
        self.clear_myself();
        self.clear_themself();
        self.clear_agent();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Origin_Segment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Origin_Segment {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Message {
    // message fields
    pub performer: ::protobuf::SingularPtrField<Origin_Segment>,
    pub at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // message oneof groups
    pub content: ::std::option::Option<Message_oneof_content>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum Message_oneof_content {
    text(::std::string::String),
    pose(::std::string::String),
}

impl Message {
    pub fn new() -> Message {
        ::std::default::Default::default()
    }

    // .haberdasher.Origin.Segment performer = 1;

    pub fn clear_performer(&mut self) {
        self.performer.clear();
    }

    pub fn has_performer(&self) -> bool {
        self.performer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_performer(&mut self, v: Origin_Segment) {
        self.performer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_performer(&mut self) -> &mut Origin_Segment {
        if self.performer.is_none() {
            self.performer.set_default();
        }
        self.performer.as_mut().unwrap()
    }

    // Take field
    pub fn take_performer(&mut self) -> Origin_Segment {
        self.performer.take().unwrap_or_else(|| Origin_Segment::new())
    }

    pub fn get_performer(&self) -> &Origin_Segment {
        self.performer.as_ref().unwrap_or_else(|| Origin_Segment::default_instance())
    }

    // .google.protobuf.Timestamp at = 2;

    pub fn clear_at(&mut self) {
        self.at.clear();
    }

    pub fn has_at(&self) -> bool {
        self.at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.at.is_none() {
            self.at.set_default();
        }
        self.at.as_mut().unwrap()
    }

    // Take field
    pub fn take_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.at.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }

    // string text = 3;

    pub fn clear_text(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::text(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.content = ::std::option::Option::Some(Message_oneof_content::text(v))
    }

    // Mutable pointer to the field.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Message_oneof_content::text(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(Message_oneof_content::text(::std::string::String::new()));
        }
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::text(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        if self.has_text() {
            match self.content.take() {
                ::std::option::Option::Some(Message_oneof_content::text(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    pub fn get_text(&self) -> &str {
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::text(ref v)) => v,
            _ => "",
        }
    }

    // string pose = 4;

    pub fn clear_pose(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_pose(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::pose(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pose(&mut self, v: ::std::string::String) {
        self.content = ::std::option::Option::Some(Message_oneof_content::pose(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pose(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Message_oneof_content::pose(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(Message_oneof_content::pose(::std::string::String::new()));
        }
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::pose(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pose(&mut self) -> ::std::string::String {
        if self.has_pose() {
            match self.content.take() {
                ::std::option::Option::Some(Message_oneof_content::pose(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    pub fn get_pose(&self) -> &str {
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::pose(ref v)) => v,
            _ => "",
        }
    }
}

impl ::protobuf::Message for Message {
    fn is_initialized(&self) -> bool {
        for v in &self.performer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.at {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.performer)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.at)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(Message_oneof_content::text(is.read_string()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(Message_oneof_content::pose(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.performer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.content {
            match v {
                &Message_oneof_content::text(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
                &Message_oneof_content::pose(ref v) => {
                    my_size += ::protobuf::rt::string_size(4, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.performer.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.at.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.content {
            match v {
                &Message_oneof_content::text(ref v) => {
                    os.write_string(3, v)?;
                },
                &Message_oneof_content::pose(ref v) => {
                    os.write_string(4, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Message {
        Message::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Origin_Segment>>(
                    "performer",
                    |m: &Message| { &m.performer },
                    |m: &mut Message| { &mut m.performer },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "at",
                    |m: &Message| { &m.at },
                    |m: &mut Message| { &mut m.at },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "text",
                    Message::has_text,
                    Message::get_text,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "pose",
                    Message::has_pose,
                    Message::get_pose,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Message>(
                    "Message",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Message {
        static mut instance: ::protobuf::lazy::Lazy<Message> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Message,
        };
        unsafe {
            instance.get(Message::new)
        }
    }
}

impl ::protobuf::Clear for Message {
    fn clear(&mut self) {
        self.clear_performer();
        self.clear_at();
        self.clear_text();
        self.clear_pose();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Message {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Message {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Venue {
    // message fields
    pub origin: ::protobuf::SingularPtrField<Origin>,
    pub last_message: ::protobuf::SingularPtrField<Message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Venue {
    pub fn new() -> Venue {
        ::std::default::Default::default()
    }

    // .haberdasher.Origin origin = 1;

    pub fn clear_origin(&mut self) {
        self.origin.clear();
    }

    pub fn has_origin(&self) -> bool {
        self.origin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin(&mut self, v: Origin) {
        self.origin = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_origin(&mut self) -> &mut Origin {
        if self.origin.is_none() {
            self.origin.set_default();
        }
        self.origin.as_mut().unwrap()
    }

    // Take field
    pub fn take_origin(&mut self) -> Origin {
        self.origin.take().unwrap_or_else(|| Origin::new())
    }

    pub fn get_origin(&self) -> &Origin {
        self.origin.as_ref().unwrap_or_else(|| Origin::default_instance())
    }

    // .haberdasher.Message last_message = 2;

    pub fn clear_last_message(&mut self) {
        self.last_message.clear();
    }

    pub fn has_last_message(&self) -> bool {
        self.last_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_message(&mut self, v: Message) {
        self.last_message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_message(&mut self) -> &mut Message {
        if self.last_message.is_none() {
            self.last_message.set_default();
        }
        self.last_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_message(&mut self) -> Message {
        self.last_message.take().unwrap_or_else(|| Message::new())
    }

    pub fn get_last_message(&self) -> &Message {
        self.last_message.as_ref().unwrap_or_else(|| Message::default_instance())
    }
}

impl ::protobuf::Message for Venue {
    fn is_initialized(&self) -> bool {
        for v in &self.origin {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.last_message {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.origin)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.last_message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.last_message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.origin.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.last_message.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Venue {
        Venue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Origin>>(
                    "origin",
                    |m: &Venue| { &m.origin },
                    |m: &mut Venue| { &mut m.origin },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Message>>(
                    "last_message",
                    |m: &Venue| { &m.last_message },
                    |m: &mut Venue| { &mut m.last_message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Venue>(
                    "Venue",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Venue {
        static mut instance: ::protobuf::lazy::Lazy<Venue> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Venue,
        };
        unsafe {
            instance.get(Venue::new)
        }
    }
}

impl ::protobuf::Clear for Venue {
    fn clear(&mut self) {
        self.clear_origin();
        self.clear_last_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Venue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Venue {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x11haberdasher.proto\x12\x0bhaberdasher\x1a\x1fgoogle/protobuf/timest\
    amp.proto\"\x07\n\x05Empty\"o\n\x0cAgentRequest\x12\x14\n\x05seqno\x18\
    \x01\x20\x01(\x03R\x05seqno\x12A\n\x0blist_venues\x18\x02\x20\x01(\x0b2\
    \x1e.haberdasher.ListVenuesRequestH\0R\nlistVenuesB\x06\n\x04kind\"\xaa\
    \x01\n\rAgentResponse\x12\x14\n\x05seqno\x18\x01\x20\x01(\x03R\x05seqno\
    \x127\n\x05error\x18\x02\x20\x01(\x0b2\x1f.haberdasher.AgentErrorRespons\
    eH\0R\x05error\x12B\n\x0blist_venues\x18\x03\x20\x01(\x0b2\x1f.haberdash\
    er.ListVenuesResponseH\0R\nlistVenuesB\x06\n\x04kind\".\n\x12AgentErrorR\
    esponse\x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07message\"]\n\x11List\
    VenuesRequest\x12H\n\x12with_updates_since\x18\x01\x20\x01(\x0b2\x1a.goo\
    gle.protobuf.TimestampR\x10withUpdatesSince\"@\n\x12ListVenuesResponse\
    \x12*\n\x06venues\x18\x01\x20\x03(\x0b2\x12.haberdasher.VenueR\x06venues\
    \"Q\n\x05Agent\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x18\n\
    \x07version\x18\x02\x20\x01(\tR\x07version\x12\x1a\n\x08revision\x18\x03\
    \x20\x01(\tR\x08revision\"0\n\nIndividual\x12\x0e\n\x02id\x18\x01\x20\
    \x01(\tR\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\"+\n\x05Gro\
    up\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x12\n\x04name\x18\x02\
    \x20\x01(\tR\x04name\"\x84\x01\n\tPerformer\x129\n\nindividual\x18\x01\
    \x20\x01(\x0b2\x17.haberdasher.IndividualH\0R\nindividual\x12\x1a\n\x07s\
    ervice\x18\x02\x20\x01(\x08H\0R\x07service\x12\x18\n\x06myself\x18\x03\
    \x20\x01(\x08H\0R\x06myselfB\x06\n\x04kind\"\xb7\x02\n\x06Origin\x12/\n\
    \x04path\x18\x01\x20\x03(\x0b2\x1b.haberdasher.Origin.SegmentR\x04path\
    \x1a\xfb\x01\n\x07Segment\x127\n\nindividual\x18\x01\x20\x01(\x0b2\x17.h\
    aberdasher.IndividualR\nindividual\x12(\n\x05group\x18\x02\x20\x01(\x0b2\
    \x12.haberdasher.GroupR\x05group\x12\x18\n\x07service\x18\x03\x20\x01(\
    \x08R\x07service\x12)\n\x10service_instance\x18\x04\x20\x01(\tR\x0fservi\
    ceInstance\x12\x16\n\x06myself\x18\x05\x20\x01(\x08R\x06myself\x12\x1a\n\
    \x08themself\x18\x06\x20\x01(\x08R\x08themself\x12\x14\n\x05agent\x18\
    \x07\x20\x01(\tR\x05agent\"\xa7\x01\n\x07Message\x129\n\tperformer\x18\
    \x01\x20\x01(\x0b2\x1b.haberdasher.Origin.SegmentR\tperformer\x12*\n\x02\
    at\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x02at\x12\x14\n\
    \x04text\x18\x03\x20\x01(\tH\0R\x04text\x12\x14\n\x04pose\x18\x04\x20\
    \x01(\tH\0R\x04poseB\t\n\x07content\"m\n\x05Venue\x12+\n\x06origin\x18\
    \x01\x20\x01(\x0b2\x13.haberdasher.OriginR\x06origin\x127\n\x0clast_mess\
    age\x18\x02\x20\x01(\x0b2\x14.haberdasher.MessageR\x0blastMessage2\xa4\
    \x01\n\x0fAgentSubscriber\x12P\n\x13HandleAgentRequests\x12\x1a.haberdas\
    her.AgentResponse\x1a\x19.haberdasher.AgentRequest(\x010\x01\x12?\n\x13P\
    ublishVenueUpdates\x12\x12.haberdasher.Venue\x1a\x12.haberdasher.Empty(\
    \x012V\n\x0fAgentAggregator\x12C\n\x17SubscribeToVenueUpdates\x12\x12.ha\
    berdasher.Empty\x1a\x12.haberdasher.Venue0\x01J\x83\x17\n\x06\x12\x04\0\
    \0\\\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x01\x08\
    \x13\n\t\n\x02\x03\0\x12\x03\x03\x07(\n\t\n\x02\x04\0\x12\x03\x05\0\x10\
    \n\n\n\x03\x04\0\x01\x12\x03\x05\x08\r\n\n\n\x02\x06\0\x12\x04\x07\0\n\
    \x01\n\n\n\x03\x06\0\x01\x12\x03\x07\x08\x17\n\x0b\n\x04\x06\0\x02\0\x12\
    \x03\x08\x04Q\n\x0c\n\x05\x06\0\x02\0\x01\x12\x03\x08\x08\x1b\n\x0c\n\
    \x05\x06\0\x02\0\x05\x12\x03\x08\x1d#\n\x0c\n\x05\x06\0\x02\0\x02\x12\
    \x03\x08$1\n\x0c\n\x05\x06\0\x02\0\x06\x12\x03\x08<B\n\x0c\n\x05\x06\0\
    \x02\0\x03\x12\x03\x08CO\n\x0b\n\x04\x06\0\x02\x01\x12\x03\t\x04;\n\x0c\
    \n\x05\x06\0\x02\x01\x01\x12\x03\t\x08\x1b\n\x0c\n\x05\x06\0\x02\x01\x05\
    \x12\x03\t\x1d#\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03\t$)\n\x0c\n\x05\
    \x06\0\x02\x01\x03\x12\x03\t49\n\n\n\x02\x06\x01\x12\x04\x0c\0\x0e\x01\n\
    \n\n\x03\x06\x01\x01\x12\x03\x0c\x08\x17\n\x0b\n\x04\x06\x01\x02\0\x12\
    \x03\r\x04?\n\x0c\n\x05\x06\x01\x02\0\x01\x12\x03\r\x08\x1f\n\x0c\n\x05\
    \x06\x01\x02\0\x02\x12\x03\r!&\n\x0c\n\x05\x06\x01\x02\0\x06\x12\x03\r17\
    \n\x0c\n\x05\x06\x01\x02\0\x03\x12\x03\r8=\n\n\n\x02\x04\x01\x12\x04\x10\
    \0\x15\x01\n\n\n\x03\x04\x01\x01\x12\x03\x10\x08\x14\n\x0b\n\x04\x04\x01\
    \x02\0\x12\x03\x11\x04\x14\n\r\n\x05\x04\x01\x02\0\x04\x12\x04\x11\x04\
    \x10\x16\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03\x11\x04\t\n\x0c\n\x05\x04\
    \x01\x02\0\x01\x12\x03\x11\n\x0f\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\
    \x11\x12\x13\n\x0c\n\x04\x04\x01\x08\0\x12\x04\x12\x04\x14\x05\n\x0c\n\
    \x05\x04\x01\x08\0\x01\x12\x03\x12\n\x0e\n\x0b\n\x04\x04\x01\x02\x01\x12\
    \x03\x13\x08*\n\x0c\n\x05\x04\x01\x02\x01\x06\x12\x03\x13\x08\x19\n\x0c\
    \n\x05\x04\x01\x02\x01\x01\x12\x03\x13\x1a%\n\x0c\n\x05\x04\x01\x02\x01\
    \x03\x12\x03\x13()\n\n\n\x02\x04\x02\x12\x04\x17\0\x1d\x01\n\n\n\x03\x04\
    \x02\x01\x12\x03\x17\x08\x15\n\x0b\n\x04\x04\x02\x02\0\x12\x03\x18\x04\
    \x14\n\r\n\x05\x04\x02\x02\0\x04\x12\x04\x18\x04\x17\x17\n\x0c\n\x05\x04\
    \x02\x02\0\x05\x12\x03\x18\x04\t\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03\
    \x18\n\x0f\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03\x18\x12\x13\n\x0c\n\x04\
    \x04\x02\x08\0\x12\x04\x19\x04\x1c\x05\n\x0c\n\x05\x04\x02\x08\0\x01\x12\
    \x03\x19\n\x0e\n\x0b\n\x04\x04\x02\x02\x01\x12\x03\x1a\x08%\n\x0c\n\x05\
    \x04\x02\x02\x01\x06\x12\x03\x1a\x08\x1a\n\x0c\n\x05\x04\x02\x02\x01\x01\
    \x12\x03\x1a\x1b\x20\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03\x1a#$\n\x0b\
    \n\x04\x04\x02\x02\x02\x12\x03\x1b\x08+\n\x0c\n\x05\x04\x02\x02\x02\x06\
    \x12\x03\x1b\x08\x1a\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03\x1b\x1b&\n\
    \x0c\n\x05\x04\x02\x02\x02\x03\x12\x03\x1b)*\n\n\n\x02\x04\x03\x12\x04\
    \x1f\0!\x01\n\n\n\x03\x04\x03\x01\x12\x03\x1f\x08\x1a\n\x0b\n\x04\x04\
    \x03\x02\0\x12\x03\x20\x04\x17\n\r\n\x05\x04\x03\x02\0\x04\x12\x04\x20\
    \x04\x1f\x1c\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03\x20\x04\n\n\x0c\n\x05\
    \x04\x03\x02\0\x01\x12\x03\x20\x0b\x12\n\x0c\n\x05\x04\x03\x02\0\x03\x12\
    \x03\x20\x15\x16\n\n\n\x02\x04\x04\x12\x04#\0%\x01\n\n\n\x03\x04\x04\x01\
    \x12\x03#\x08\x19\n\x0b\n\x04\x04\x04\x02\0\x12\x03$\x045\n\r\n\x05\x04\
    \x04\x02\0\x04\x12\x04$\x04#\x1b\n\x0c\n\x05\x04\x04\x02\0\x06\x12\x03$\
    \x04\x1d\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03$\x1e0\n\x0c\n\x05\x04\x04\
    \x02\0\x03\x12\x03$34\n\n\n\x02\x04\x05\x12\x04'\0)\x01\n\n\n\x03\x04\
    \x05\x01\x12\x03'\x08\x1a\n\x0b\n\x04\x04\x05\x02\0\x12\x03(\x04\x1e\n\
    \x0c\n\x05\x04\x05\x02\0\x04\x12\x03(\x04\x0c\n\x0c\n\x05\x04\x05\x02\0\
    \x06\x12\x03(\r\x12\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03(\x13\x19\n\x0c\
    \n\x05\x04\x05\x02\0\x03\x12\x03(\x1c\x1d\n\n\n\x02\x04\x06\x12\x04+\0/\
    \x01\n\n\n\x03\x04\x06\x01\x12\x03+\x08\r\n\x0b\n\x04\x04\x06\x02\0\x12\
    \x03,\x04\x14\n\r\n\x05\x04\x06\x02\0\x04\x12\x04,\x04+\x0f\n\x0c\n\x05\
    \x04\x06\x02\0\x05\x12\x03,\x04\n\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03,\
    \x0b\x0f\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03,\x12\x13\n\x0b\n\x04\x04\
    \x06\x02\x01\x12\x03-\x04\x17\n\r\n\x05\x04\x06\x02\x01\x04\x12\x04-\x04\
    ,\x14\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03-\x04\n\n\x0c\n\x05\x04\x06\
    \x02\x01\x01\x12\x03-\x0b\x12\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03-\
    \x15\x16\n\x0b\n\x04\x04\x06\x02\x02\x12\x03.\x04\x18\n\r\n\x05\x04\x06\
    \x02\x02\x04\x12\x04.\x04-\x17\n\x0c\n\x05\x04\x06\x02\x02\x05\x12\x03.\
    \x04\n\n\x0c\n\x05\x04\x06\x02\x02\x01\x12\x03.\x0b\x13\n\x0c\n\x05\x04\
    \x06\x02\x02\x03\x12\x03.\x16\x17\n\n\n\x02\x04\x07\x12\x041\04\x01\n\n\
    \n\x03\x04\x07\x01\x12\x031\x08\x12\n\x0b\n\x04\x04\x07\x02\0\x12\x032\
    \x04\x12\n\r\n\x05\x04\x07\x02\0\x04\x12\x042\x041\x14\n\x0c\n\x05\x04\
    \x07\x02\0\x05\x12\x032\x04\n\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x032\x0b\
    \r\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x032\x10\x11\n\x0b\n\x04\x04\x07\
    \x02\x01\x12\x033\x04\x14\n\r\n\x05\x04\x07\x02\x01\x04\x12\x043\x042\
    \x12\n\x0c\n\x05\x04\x07\x02\x01\x05\x12\x033\x04\n\n\x0c\n\x05\x04\x07\
    \x02\x01\x01\x12\x033\x0b\x0f\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x033\
    \x12\x13\n\n\n\x02\x04\x08\x12\x046\09\x01\n\n\n\x03\x04\x08\x01\x12\x03\
    6\x08\r\n\x0b\n\x04\x04\x08\x02\0\x12\x037\x04\x12\n\r\n\x05\x04\x08\x02\
    \0\x04\x12\x047\x046\x0f\n\x0c\n\x05\x04\x08\x02\0\x05\x12\x037\x04\n\n\
    \x0c\n\x05\x04\x08\x02\0\x01\x12\x037\x0b\r\n\x0c\n\x05\x04\x08\x02\0\
    \x03\x12\x037\x10\x11\n\x0b\n\x04\x04\x08\x02\x01\x12\x038\x04\x14\n\r\n\
    \x05\x04\x08\x02\x01\x04\x12\x048\x047\x12\n\x0c\n\x05\x04\x08\x02\x01\
    \x05\x12\x038\x04\n\n\x0c\n\x05\x04\x08\x02\x01\x01\x12\x038\x0b\x0f\n\
    \x0c\n\x05\x04\x08\x02\x01\x03\x12\x038\x12\x13\n\n\n\x02\x04\t\x12\x04;\
    \0A\x01\n\n\n\x03\x04\t\x01\x12\x03;\x08\x11\n\x0c\n\x04\x04\t\x08\0\x12\
    \x04<\x04@\x05\n\x0c\n\x05\x04\t\x08\0\x01\x12\x03<\n\x0e\n\x0b\n\x04\
    \x04\t\x02\0\x12\x03=\x08\"\n\x0c\n\x05\x04\t\x02\0\x06\x12\x03=\x08\x12\
    \n\x0c\n\x05\x04\t\x02\0\x01\x12\x03=\x13\x1d\n\x0c\n\x05\x04\t\x02\0\
    \x03\x12\x03=\x20!\n\x0b\n\x04\x04\t\x02\x01\x12\x03>\x08\x19\n\x0c\n\
    \x05\x04\t\x02\x01\x05\x12\x03>\x08\x0c\n\x0c\n\x05\x04\t\x02\x01\x01\
    \x12\x03>\r\x14\n\x0c\n\x05\x04\t\x02\x01\x03\x12\x03>\x17\x18\n\x0b\n\
    \x04\x04\t\x02\x02\x12\x03?\x08\x18\n\x0c\n\x05\x04\t\x02\x02\x05\x12\
    \x03?\x08\x0c\n\x0c\n\x05\x04\t\x02\x02\x01\x12\x03?\r\x13\n\x0c\n\x05\
    \x04\t\x02\x02\x03\x12\x03?\x16\x17\n\n\n\x02\x04\n\x12\x04C\0N\x01\n\n\
    \n\x03\x04\n\x01\x12\x03C\x08\x0e\n\x0c\n\x04\x04\n\x03\0\x12\x04D\x04L\
    \x05\n\x0c\n\x05\x04\n\x03\0\x01\x12\x03D\x0c\x13\n\r\n\x06\x04\n\x03\0\
    \x02\0\x12\x03E\x08\"\n\x0f\n\x07\x04\n\x03\0\x02\0\x04\x12\x04E\x08D\
    \x15\n\x0e\n\x07\x04\n\x03\0\x02\0\x06\x12\x03E\x08\x12\n\x0e\n\x07\x04\
    \n\x03\0\x02\0\x01\x12\x03E\x13\x1d\n\x0e\n\x07\x04\n\x03\0\x02\0\x03\
    \x12\x03E\x20!\n\r\n\x06\x04\n\x03\0\x02\x01\x12\x03F\x08\x18\n\x0f\n\
    \x07\x04\n\x03\0\x02\x01\x04\x12\x04F\x08E\"\n\x0e\n\x07\x04\n\x03\0\x02\
    \x01\x06\x12\x03F\x08\r\n\x0e\n\x07\x04\n\x03\0\x02\x01\x01\x12\x03F\x0e\
    \x13\n\x0e\n\x07\x04\n\x03\0\x02\x01\x03\x12\x03F\x16\x17\n\r\n\x06\x04\
    \n\x03\0\x02\x02\x12\x03G\x08\x19\n\x0f\n\x07\x04\n\x03\0\x02\x02\x04\
    \x12\x04G\x08F\x18\n\x0e\n\x07\x04\n\x03\0\x02\x02\x05\x12\x03G\x08\x0c\
    \n\x0e\n\x07\x04\n\x03\0\x02\x02\x01\x12\x03G\r\x14\n\x0e\n\x07\x04\n\
    \x03\0\x02\x02\x03\x12\x03G\x17\x18\n\r\n\x06\x04\n\x03\0\x02\x03\x12\
    \x03H\x08$\n\x0f\n\x07\x04\n\x03\0\x02\x03\x04\x12\x04H\x08G\x19\n\x0e\n\
    \x07\x04\n\x03\0\x02\x03\x05\x12\x03H\x08\x0e\n\x0e\n\x07\x04\n\x03\0\
    \x02\x03\x01\x12\x03H\x0f\x1f\n\x0e\n\x07\x04\n\x03\0\x02\x03\x03\x12\
    \x03H\"#\n\r\n\x06\x04\n\x03\0\x02\x04\x12\x03I\x08\x18\n\x0f\n\x07\x04\
    \n\x03\0\x02\x04\x04\x12\x04I\x08H$\n\x0e\n\x07\x04\n\x03\0\x02\x04\x05\
    \x12\x03I\x08\x0c\n\x0e\n\x07\x04\n\x03\0\x02\x04\x01\x12\x03I\r\x13\n\
    \x0e\n\x07\x04\n\x03\0\x02\x04\x03\x12\x03I\x16\x17\n\r\n\x06\x04\n\x03\
    \0\x02\x05\x12\x03J\x08\x1a\n\x0f\n\x07\x04\n\x03\0\x02\x05\x04\x12\x04J\
    \x08I\x18\n\x0e\n\x07\x04\n\x03\0\x02\x05\x05\x12\x03J\x08\x0c\n\x0e\n\
    \x07\x04\n\x03\0\x02\x05\x01\x12\x03J\r\x15\n\x0e\n\x07\x04\n\x03\0\x02\
    \x05\x03\x12\x03J\x18\x19\n\r\n\x06\x04\n\x03\0\x02\x06\x12\x03K\x08\x19\
    \n\x0f\n\x07\x04\n\x03\0\x02\x06\x04\x12\x04K\x08J\x1a\n\x0e\n\x07\x04\n\
    \x03\0\x02\x06\x05\x12\x03K\x08\x0e\n\x0e\n\x07\x04\n\x03\0\x02\x06\x01\
    \x12\x03K\x0f\x14\n\x0e\n\x07\x04\n\x03\0\x02\x06\x03\x12\x03K\x17\x18\n\
    \x0b\n\x04\x04\n\x02\0\x12\x03M\x04\x1e\n\x0c\n\x05\x04\n\x02\0\x04\x12\
    \x03M\x04\x0c\n\x0c\n\x05\x04\n\x02\0\x06\x12\x03M\r\x14\n\x0c\n\x05\x04\
    \n\x02\0\x01\x12\x03M\x15\x19\n\x0c\n\x05\x04\n\x02\0\x03\x12\x03M\x1c\
    \x1d\n\n\n\x02\x04\x0b\x12\x04P\0W\x01\n\n\n\x03\x04\x0b\x01\x12\x03P\
    \x08\x0f\n\x0b\n\x04\x04\x0b\x02\0\x12\x03Q\x04!\n\r\n\x05\x04\x0b\x02\0\
    \x04\x12\x04Q\x04P\x11\n\x0c\n\x05\x04\x0b\x02\0\x06\x12\x03Q\x04\x12\n\
    \x0c\n\x05\x04\x0b\x02\0\x01\x12\x03Q\x13\x1c\n\x0c\n\x05\x04\x0b\x02\0\
    \x03\x12\x03Q\x1f\x20\n\x0b\n\x04\x04\x0b\x02\x01\x12\x03R\x04%\n\r\n\
    \x05\x04\x0b\x02\x01\x04\x12\x04R\x04Q!\n\x0c\n\x05\x04\x0b\x02\x01\x06\
    \x12\x03R\x04\x1d\n\x0c\n\x05\x04\x0b\x02\x01\x01\x12\x03R\x1e\x20\n\x0c\
    \n\x05\x04\x0b\x02\x01\x03\x12\x03R#$\n\x0c\n\x04\x04\x0b\x08\0\x12\x04S\
    \x04V\x05\n\x0c\n\x05\x04\x0b\x08\0\x01\x12\x03S\n\x11\n\x0b\n\x04\x04\
    \x0b\x02\x02\x12\x03T\x08\x18\n\x0c\n\x05\x04\x0b\x02\x02\x05\x12\x03T\
    \x08\x0e\n\x0c\n\x05\x04\x0b\x02\x02\x01\x12\x03T\x0f\x13\n\x0c\n\x05\
    \x04\x0b\x02\x02\x03\x12\x03T\x16\x17\n\x0b\n\x04\x04\x0b\x02\x03\x12\
    \x03U\x08\x18\n\x0c\n\x05\x04\x0b\x02\x03\x05\x12\x03U\x08\x0e\n\x0c\n\
    \x05\x04\x0b\x02\x03\x01\x12\x03U\x0f\x13\n\x0c\n\x05\x04\x0b\x02\x03\
    \x03\x12\x03U\x16\x17\n\n\n\x02\x04\x0c\x12\x04Y\0\\\x01\n\n\n\x03\x04\
    \x0c\x01\x12\x03Y\x08\r\n\x0b\n\x04\x04\x0c\x02\0\x12\x03Z\x04\x16\n\r\n\
    \x05\x04\x0c\x02\0\x04\x12\x04Z\x04Y\x0f\n\x0c\n\x05\x04\x0c\x02\0\x06\
    \x12\x03Z\x04\n\n\x0c\n\x05\x04\x0c\x02\0\x01\x12\x03Z\x0b\x11\n\x0c\n\
    \x05\x04\x0c\x02\0\x03\x12\x03Z\x14\x15\n\x0b\n\x04\x04\x0c\x02\x01\x12\
    \x03[\x04\x1d\n\r\n\x05\x04\x0c\x02\x01\x04\x12\x04[\x04Z\x16\n\x0c\n\
    \x05\x04\x0c\x02\x01\x06\x12\x03[\x04\x0b\n\x0c\n\x05\x04\x0c\x02\x01\
    \x01\x12\x03[\x0c\x18\n\x0c\n\x05\x04\x0c\x02\x01\x03\x12\x03[\x1b\x1cb\
    \x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
